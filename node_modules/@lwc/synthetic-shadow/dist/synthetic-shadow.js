/* proxy-compat-disable */
function invariant(value, msg) {
  if (!value) {
    throw new Error(`Invariant Violation: ${msg}`);
  }
}

function isTrue(value, msg) {
  if (!value) {
    throw new Error(`Assert Violation: ${msg}`);
  }
}

function isFalse(value, msg) {
  if (value) {
    throw new Error(`Assert Violation: ${msg}`);
  }
}

function fail(msg) {
  throw new Error(msg);
}

var assert = Object.freeze({
  invariant: invariant,
  isTrue: isTrue,
  isFalse: isFalse,
  fail: fail
});
const {
  assign,
  create,
  defineProperties,
  defineProperty,
  freeze,
  getOwnPropertyDescriptor,
  getOwnPropertyNames,
  getPrototypeOf,
  hasOwnProperty,
  keys,
  seal,
  setPrototypeOf
} = Object;
const {
  isArray
} = Array;
const {
  constructor: ArrayConstructor,
  filter: ArrayFilter,
  find: ArrayFind,
  forEach,
  indexOf: ArrayIndexOf,
  join: ArrayJoin,
  map: ArrayMap,
  push: ArrayPush,
  reduce: ArrayReduce,
  reverse: ArrayReverse,
  slice: ArraySlice,
  splice: ArraySplice,
  unshift: ArrayUnshift
} = Array.prototype;
const {
  charCodeAt: StringCharCodeAt,
  replace: StringReplace,
  slice: StringSlice,
  toLowerCase: StringToLowerCase
} = String.prototype;

function isUndefined(obj) {
  return obj === undefined;
}

function isNull(obj) {
  return obj === null;
}

function isTrue$1(obj) {
  return obj === true;
}

function isFalse$1(obj) {
  return obj === false;
}

function isFunction(obj) {
  return typeof obj === 'function';
}

const OtS = {}.toString;

function toString(obj) {
  if (obj && obj.toString) {
    if (isArray(obj)) {
      return ArrayJoin.call(ArrayMap.call(obj, toString), ',');
    }

    return obj.toString();
  } else if (typeof obj === 'object') {
    return OtS.call(obj);
  } else {
    return obj + emptyString;
  }
}

function getPropertyDescriptor(o, p) {
  do {
    const d = getOwnPropertyDescriptor(o, p);

    if (!isUndefined(d)) {
      return d;
    }

    o = getPrototypeOf(o);
  } while (o !== null);
}

const emptyString = '';
const hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';

function createFieldName(key, namespace) {
  return hasNativeSymbolsSupport ? Symbol(key) : `$$lwc-${namespace}-${key}$$`;
}

const hiddenFieldsMap = new WeakMap();

function setHiddenField(o, fieldName, value) {
  let valuesByField = hiddenFieldsMap.get(o);

  if (isUndefined(valuesByField)) {
    valuesByField = create(null);
    hiddenFieldsMap.set(o, valuesByField);
  }

  valuesByField[fieldName] = value;
}

function getHiddenField(o, fieldName) {
  const valuesByField = hiddenFieldsMap.get(o);

  if (!isUndefined(valuesByField)) {
    return valuesByField[fieldName];
  }
}

var fields = Object.freeze({
  createFieldName: createFieldName,
  setHiddenField: setHiddenField,
  getHiddenField: getHiddenField
});

const {
  DOCUMENT_POSITION_CONTAINED_BY,
  DOCUMENT_POSITION_CONTAINS,
  DOCUMENT_POSITION_PRECEDING,
  DOCUMENT_POSITION_FOLLOWING,
  ELEMENT_NODE,
  TEXT_NODE,
  CDATA_SECTION_NODE,
  PROCESSING_INSTRUCTION_NODE,
  COMMENT_NODE,
  DOCUMENT_FRAGMENT_NODE
} = Node;
const {
  appendChild,
  cloneNode,
  compareDocumentPosition,
  insertBefore,
  removeChild,
  replaceChild,
  hasChildNodes
} = Node.prototype;
const {
  contains
} = HTMLElement.prototype;
const firstChildGetter = getOwnPropertyDescriptor(Node.prototype, 'firstChild').get;
const lastChildGetter = getOwnPropertyDescriptor(Node.prototype, 'lastChild').get;
const textContentGetter = getOwnPropertyDescriptor(Node.prototype, 'textContent').get;
const parentNodeGetter = getOwnPropertyDescriptor(Node.prototype, 'parentNode').get;
const ownerDocumentGetter = getOwnPropertyDescriptor(Node.prototype, 'ownerDocument').get;
const parentElementGetter = hasOwnProperty.call(Node.prototype, 'parentElement') ? getOwnPropertyDescriptor(Node.prototype, 'parentElement').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement').get;
const textContextSetter = getOwnPropertyDescriptor(Node.prototype, 'textContent').set;
const childNodesGetter = hasOwnProperty.call(Node.prototype, 'childNodes') ? getOwnPropertyDescriptor(Node.prototype, 'childNodes').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'childNodes').get;
const isConnected = hasOwnProperty.call(Node.prototype, 'isConnected') ? getOwnPropertyDescriptor(Node.prototype, 'isConnected').get : function () {
  const doc = ownerDocumentGetter.call(this);
  return doc === null || (compareDocumentPosition.call(doc, this) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
};

const {
  hasAttribute,
  getAttribute,
  setAttribute,
  removeAttribute,
  querySelectorAll,
  getBoundingClientRect,
  getElementsByTagName,
  getElementsByTagNameNS
} = Element.prototype;
const {
  addEventListener,
  removeEventListener
} = Element.prototype;
const childElementCountGetter = getOwnPropertyDescriptor(Element.prototype, 'childElementCount').get;
const firstElementChildGetter = getOwnPropertyDescriptor(Element.prototype, 'firstElementChild').get;
const lastElementChildGetter = getOwnPropertyDescriptor(Element.prototype, 'lastElementChild').get;
const innerHTMLDescriptor = hasOwnProperty.call(Element.prototype, 'innerHTML') ? getOwnPropertyDescriptor(Element.prototype, 'innerHTML') : getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML');
const innerHTMLGetter = innerHTMLDescriptor.get;
const innerHTMLSetter = innerHTMLDescriptor.set;
const outerHTMLDescriptor = hasOwnProperty.call(Element.prototype, 'outerHTML') ? getOwnPropertyDescriptor(Element.prototype, 'outerHTML') : getOwnPropertyDescriptor(HTMLElement.prototype, 'outerHTML');
const outerHTMLGetter = outerHTMLDescriptor.get;
const outerHTMLSetter = outerHTMLDescriptor.set;
const tagNameGetter = getOwnPropertyDescriptor(Element.prototype, 'tagName').get;
const tabIndexDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, 'tabIndex');
const tabIndexGetter = tabIndexDescriptor.get;
const tabIndexSetter = tabIndexDescriptor.set;
const matches = hasOwnProperty.call(Element.prototype, 'matches') ? Element.prototype.matches : Element.prototype.msMatchesSelector;
const childrenGetter = hasOwnProperty.call(Element.prototype, 'children') ? getOwnPropertyDescriptor(Element.prototype, 'children').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'children').get;
const {
  getElementsByClassName
} = HTMLElement.prototype;

const dispatchEvent = 'EventTarget' in window ? EventTarget.prototype.dispatchEvent : Node.prototype.dispatchEvent;
const eventTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'target').get;
const eventCurrentTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'currentTarget').get;
const focusEventRelatedTargetGetter = getOwnPropertyDescriptor(FocusEvent.prototype, 'relatedTarget').get;

const DocumentPrototypeActiveElement = getOwnPropertyDescriptor(Document.prototype, 'activeElement').get;
const elementFromPoint = hasOwnProperty.call(Document.prototype, 'elementFromPoint') ? Document.prototype.elementFromPoint : Document.prototype.msElementFromPoint;
const defaultViewGetter = getOwnPropertyDescriptor(Document.prototype, 'defaultView').get;
const {
  createComment,
  querySelectorAll: querySelectorAll$1,
  getElementById,
  getElementsByClassName: getElementsByClassName$1,
  getElementsByTagName: getElementsByTagName$1,
  getElementsByTagNameNS: getElementsByTagNameNS$1
} = Document.prototype;
const {
  getElementsByName
} = HTMLDocument.prototype;

const {
  addEventListener: windowAddEventListener,
  removeEventListener: windowRemoveEventListener
} = window;

const MO = MutationObserver;
const MutationObserverObserve = MO.prototype.observe;

function detect () {
  return typeof HTMLSlotElement === 'undefined';
}

const {
  createElement
} = Document.prototype;
const CHAR_S = 115;
const CHAR_L = 108;
const CHAR_O = 111;
const CHAR_T = 116;
function apply() {
  class HTMLSlotElement {}

  setPrototypeOf(HTMLSlotElement, HTMLElement.constructor);
  setPrototypeOf(HTMLSlotElement.prototype, HTMLElement.prototype);
  Window.prototype.HTMLSlotElement = HTMLSlotElement;
  defineProperty(Document.prototype, 'createElement', {
    value: function (tagName, _options) {
      const elm = createElement.apply(this, ArraySlice.call(arguments));

      if (tagName.length === 4 && StringCharCodeAt.call(tagName, 0) === CHAR_S && StringCharCodeAt.call(tagName, 1) === CHAR_L && StringCharCodeAt.call(tagName, 2) === CHAR_O && StringCharCodeAt.call(tagName, 3) === CHAR_T) {
        setPrototypeOf(elm, HTMLSlotElement.prototype);
      }

      return elm;
    }
  });
}

if (detect()) {
  apply();
}

const {
  assign: assign$1,
  create: create$1,
  defineProperties: defineProperties$1,
  defineProperty: defineProperty$1,
  freeze: freeze$1,
  getOwnPropertyDescriptor: getOwnPropertyDescriptor$1,
  getOwnPropertyNames: getOwnPropertyNames$1,
  getPrototypeOf: getPrototypeOf$1,
  hasOwnProperty: hasOwnProperty$1,
  keys: keys$1,
  seal: seal$1,
  setPrototypeOf: setPrototypeOf$1
} = Object;

const hasNativeSymbolsSupport$1 = Symbol('x').toString() === 'Symbol(x)';
const runtimeFlags = create$1(null);

function getOwnerDocument(node) {
  const doc = ownerDocumentGetter.call(node);
  return doc === null ? node : doc;
}
function getOwnerWindow(node) {
  const doc = getOwnerDocument(node);
  const win = defaultViewGetter.call(doc);

  if (win === null) {
    throw new TypeError();
  }

  return win;
}
let skipGlobalPatching;
function isGlobalPatchingSkipped(node) {
  if (isUndefined(skipGlobalPatching)) {
    const ownerDocument = getOwnerDocument(node);
    skipGlobalPatching = ownerDocument.body && getAttribute.call(ownerDocument.body, 'data-global-patching-bypass') === 'temporary-bypass';
  }

  return isTrue$1(skipGlobalPatching);
}
function arrayFromCollection(collection) {
  const size = collection.length;
  const cloned = new ArrayConstructor(size);

  if (size > 0) {
    for (let i = 0; i < size; i++) {
      cloned[i] = collection[i];
    }
  }

  return cloned;
}

function pathComposer(startNode, composed) {
  const composedPath = [];
  let current = startNode;
  const startRoot = startNode instanceof Window ? startNode : startNode.getRootNode();

  while (!isNull(current)) {
    composedPath.push(current);
    let assignedSlot = null;

    if (current instanceof Element) {
      assignedSlot = current.assignedSlot;
    }

    if (!isNull(assignedSlot)) {
      current = assignedSlot;
    } else if (current instanceof ShadowRoot && (composed || current !== startRoot)) {
      current = current.host;
    } else {
      current = current.parentNode;
    }
  }

  let doc;

  if (startNode instanceof Window) {
    doc = startNode.document;
  } else {
    doc = getOwnerDocument(startNode);
  }

  if (composedPath[composedPath.length - 1] === doc) {
    composedPath.push(window);
  }

  return composedPath;
}

function retarget(refNode, path) {
  if (isNull(refNode)) {
    return null;
  }

  const refNodePath = pathComposer(refNode, true);
  const p$ = path;

  for (let i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {
    ancestor = p$[i];
    root = ancestor instanceof Window ? ancestor : ancestor.getRootNode();

    if (root !== lastRoot) {
      rootIdx = refNodePath.indexOf(root);
      lastRoot = root;
    }

    if (!(root instanceof SyntheticShadowRoot) || rootIdx > -1) {
      return ancestor;
    }
  }

  return null;
}

var EventListenerContext;

(function (EventListenerContext) {
  EventListenerContext[EventListenerContext["CUSTOM_ELEMENT_LISTENER"] = 1] = "CUSTOM_ELEMENT_LISTENER";
  EventListenerContext[EventListenerContext["SHADOW_ROOT_LISTENER"] = 2] = "SHADOW_ROOT_LISTENER";
})(EventListenerContext || (EventListenerContext = {}));

const eventToContextMap = new WeakMap();

function isChildNode(root, node) {
  return !!(compareDocumentPosition.call(root, node) & DOCUMENT_POSITION_CONTAINED_BY);
}

const GET_ROOT_NODE_CONFIG_FALSE = {
  composed: false
};

function getRootNodeHost(node, options) {
  let rootNode = node.getRootNode(options);

  if ('mode' in rootNode && 'delegatesFocus' in rootNode) {
    rootNode = getHost(rootNode);
  }

  return rootNode;
}

function targetGetter() {
  const originalCurrentTarget = eventCurrentTargetGetter.call(this);
  const originalTarget = eventTargetGetter.call(this);
  const composedPath = pathComposer(originalTarget, this.composed);
  const doc = getOwnerDocument(originalTarget);

  if (!(originalCurrentTarget instanceof Node)) {
    if (isNull(originalCurrentTarget) && isUndefined(getNodeOwnerKey(originalTarget))) {
      return originalTarget;
    }

    return retarget(doc, composedPath);
  } else if (originalCurrentTarget === doc || originalCurrentTarget === doc.body) {
    if (isUndefined(getNodeOwnerKey(originalTarget))) {
      return originalTarget;
    }

    return retarget(doc, composedPath);
  }

  const eventContext = eventToContextMap.get(this);
  const currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER ? getShadowRoot(originalCurrentTarget) : originalCurrentTarget;
  return retarget(currentTarget, composedPath);
}

function composedPathValue() {
  const originalTarget = eventTargetGetter.call(this);
  const originalCurrentTarget = eventCurrentTargetGetter.call(this);
  return isNull(originalCurrentTarget) ? [] : pathComposer(originalTarget, this.composed);
}

function patchEvent(event) {
  if (eventToContextMap.has(event)) {
    return;
  }

  defineProperties(event, {
    target: {
      get: targetGetter,
      enumerable: true,
      configurable: true
    },
    composedPath: {
      value: composedPathValue,
      writable: true,
      enumerable: true,
      configurable: true
    },
    srcElement: {
      get: targetGetter,
      enumerable: true,
      configurable: true
    },
    path: {
      get: composedPathValue,
      enumerable: true,
      configurable: true
    }
  });
  const originalRelatedTargetDescriptor = getPropertyDescriptor(event, 'relatedTarget');

  if (!isUndefined(originalRelatedTargetDescriptor)) {
    const relatedTargetGetter = originalRelatedTargetDescriptor.get;
    defineProperty(event, 'relatedTarget', {
      get() {
        const eventContext = eventToContextMap.get(this);
        const originalCurrentTarget = eventCurrentTargetGetter.call(this);
        const relatedTarget = relatedTargetGetter.call(this);

        if (isNull(relatedTarget)) {
          return null;
        }

        const currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER ? getShadowRoot(originalCurrentTarget) : originalCurrentTarget;
        return retarget(currentTarget, pathComposer(relatedTarget, true));
      },

      enumerable: true,
      configurable: true
    });
  }

  eventToContextMap.set(event, 0);
}
const customElementToWrappedListeners = new WeakMap();

function getEventMap(elm) {
  let listenerInfo = customElementToWrappedListeners.get(elm);

  if (isUndefined(listenerInfo)) {
    listenerInfo = create(null);
    customElementToWrappedListeners.set(elm, listenerInfo);
  }

  return listenerInfo;
}

const shadowRootEventListenerMap = new WeakMap();

function getWrappedShadowRootListener(sr, listener) {
  if (!isFunction(listener)) {
    throw new TypeError();
  }

  let shadowRootWrappedListener = shadowRootEventListenerMap.get(listener);

  if (isUndefined(shadowRootWrappedListener)) {
    shadowRootWrappedListener = function (event) {
      const {
        composed
      } = event;
      const target = eventTargetGetter.call(event);
      const currentTarget = eventCurrentTargetGetter.call(event);

      if (target !== currentTarget) {
        const rootNode = getRootNodeHost(target, {
          composed
        });

        if (isChildNode(rootNode, currentTarget) || composed === false && rootNode === currentTarget) {
          listener.call(sr, event);
        }
      }
    };

    shadowRootWrappedListener.placement = EventListenerContext.SHADOW_ROOT_LISTENER;

    if (process.env.NODE_ENV !== 'production') {
      shadowRootWrappedListener.original = listener;
    }

    shadowRootEventListenerMap.set(listener, shadowRootWrappedListener);
  }

  return shadowRootWrappedListener;
}

const customElementEventListenerMap = new WeakMap();

function getWrappedCustomElementListener(elm, listener) {
  if (!isFunction(listener)) {
    throw new TypeError();
  }

  let customElementWrappedListener = customElementEventListenerMap.get(listener);

  if (isUndefined(customElementWrappedListener)) {
    customElementWrappedListener = function (event) {
      if (isValidEventForCustomElement(event)) {
        listener.call(elm, event);
      }
    };

    customElementWrappedListener.placement = EventListenerContext.CUSTOM_ELEMENT_LISTENER;

    if (process.env.NODE_ENV !== 'production') {
      customElementWrappedListener.original = listener;
    }

    customElementEventListenerMap.set(listener, customElementWrappedListener);
  }

  return customElementWrappedListener;
}

function domListener(evt) {
  patchEvent(evt);
  let immediatePropagationStopped = false;
  let propagationStopped = false;
  const {
    type,
    stopImmediatePropagation,
    stopPropagation
  } = evt;
  const currentTarget = eventCurrentTargetGetter.call(evt);
  const listenerMap = getEventMap(currentTarget);
  const listeners = listenerMap[type];
  defineProperty(evt, 'stopImmediatePropagation', {
    value() {
      immediatePropagationStopped = true;
      stopImmediatePropagation.call(evt);
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(evt, 'stopPropagation', {
    value() {
      propagationStopped = true;
      stopPropagation.call(evt);
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  const bookkeeping = ArraySlice.call(listeners);

  function invokeListenersByPlacement(placement) {
    forEach.call(bookkeeping, listener => {
      if (isFalse$1(immediatePropagationStopped) && listener.placement === placement) {
        if (ArrayIndexOf.call(listeners, listener) !== -1) {
          listener.call(undefined, evt);
        }
      }
    });
  }

  eventToContextMap.set(evt, EventListenerContext.SHADOW_ROOT_LISTENER);
  invokeListenersByPlacement(EventListenerContext.SHADOW_ROOT_LISTENER);

  if (isFalse$1(immediatePropagationStopped) && isFalse$1(propagationStopped)) {
    eventToContextMap.set(evt, EventListenerContext.CUSTOM_ELEMENT_LISTENER);
    invokeListenersByPlacement(EventListenerContext.CUSTOM_ELEMENT_LISTENER);
  }

  eventToContextMap.set(evt, 0);
}

function attachDOMListener(elm, type, wrappedListener) {
  const listenerMap = getEventMap(elm);
  let cmpEventHandlers = listenerMap[type];

  if (isUndefined(cmpEventHandlers)) {
    cmpEventHandlers = listenerMap[type] = [];
  }

  if (cmpEventHandlers.length === 0) {
    addEventListener.call(elm, type, domListener);
  }

  ArrayPush.call(cmpEventHandlers, wrappedListener);
}

function detachDOMListener(elm, type, wrappedListener) {
  const listenerMap = getEventMap(elm);
  let p;
  let listeners;

  if (!isUndefined(listeners = listenerMap[type]) && (p = ArrayIndexOf.call(listeners, wrappedListener)) !== -1) {
    ArraySplice.call(listeners, p, 1);

    if (listeners.length === 0) {
      removeEventListener.call(elm, type, domListener);
    }
  }
}

function isValidEventForCustomElement(event) {
  const target = eventTargetGetter.call(event);
  const currentTarget = eventCurrentTargetGetter.call(event);
  const {
    composed
  } = event;
  return composed === true || target === currentTarget || isChildNode(getRootNodeHost(target, GET_ROOT_NODE_CONFIG_FALSE), currentTarget);
}

function addCustomElementEventListener(elm, type, listener, _options) {
  if (process.env.NODE_ENV !== 'production') {
    if (!isFunction(listener)) {
      throw new TypeError(`Invalid second argument for Element.addEventListener() in ${toString(elm)} for event "${type}". Expected an EventListener but received ${listener}.`);
    }
  }

  const wrappedListener = getWrappedCustomElementListener(elm, listener);
  attachDOMListener(elm, type, wrappedListener);
}
function removeCustomElementEventListener(elm, type, listener, _options) {
  const wrappedListener = getWrappedCustomElementListener(elm, listener);
  detachDOMListener(elm, type, wrappedListener);
}
function addShadowRootEventListener(sr, type, listener, _options) {
  if (process.env.NODE_ENV !== 'production') {
    if (!isFunction(listener)) {
      throw new TypeError(`Invalid second argument for ShadowRoot.addEventListener() in ${toString(sr)} for event "${type}". Expected an EventListener but received ${listener}.`);
    }
  }

  const elm = getHost(sr);
  const wrappedListener = getWrappedShadowRootListener(sr, listener);
  attachDOMListener(elm, type, wrappedListener);
}
function removeShadowRootEventListener(sr, type, listener, _options) {
  const elm = getHost(sr);
  const wrappedListener = getWrappedShadowRootListener(sr, listener);
  detachDOMListener(elm, type, wrappedListener);
}

function getTextContent(node) {
  switch (node.nodeType) {
    case ELEMENT_NODE:
      {
        const childNodes = getFilteredChildNodes(node);
        let content = '';

        for (let i = 0, len = childNodes.length; i < len; i += 1) {
          const currentNode = childNodes[i];

          if (currentNode.nodeType !== COMMENT_NODE) {
            content += getTextContent(currentNode);
          }
        }

        return content;
      }

    default:
      return node.nodeValue;
  }
}

const {
  createFieldName: createFieldName$1,
  getHiddenField: getHiddenField$1,
  setHiddenField: setHiddenField$1
} = fields;
const Items = createFieldName$1('items', 'synthetic-shadow');

function StaticNodeList() {
  throw new TypeError('Illegal constructor');
}

StaticNodeList.prototype = create(NodeList.prototype, {
  constructor: {
    writable: true,
    configurable: true,
    value: StaticNodeList
  },
  item: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(index) {
      return this[index];
    }

  },
  length: {
    enumerable: true,
    configurable: true,

    get() {
      return getHiddenField$1(this, Items).length;
    }

  },
  forEach: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(cb, thisArg) {
      forEach.call(getHiddenField$1(this, Items), cb, thisArg);
    }

  },
  entries: {
    writable: true,
    enumerable: true,
    configurable: true,

    value() {
      return ArrayMap.call(getHiddenField$1(this, Items), (v, i) => [i, v]);
    }

  },
  keys: {
    writable: true,
    enumerable: true,
    configurable: true,

    value() {
      return ArrayMap.call(getHiddenField$1(this, Items), (v, i) => i);
    }

  },
  values: {
    writable: true,
    enumerable: true,
    configurable: true,

    value() {
      return getHiddenField$1(this, Items);
    }

  },
  [Symbol.iterator]: {
    writable: true,
    configurable: true,

    value() {
      let nextIndex = 0;
      return {
        next: () => {
          const items = getHiddenField$1(this, Items);
          return nextIndex < items.length ? {
            value: items[nextIndex++],
            done: false
          } : {
            done: true
          };
        }
      };
    }

  },
  [Symbol.toStringTag]: {
    configurable: true,

    get() {
      return 'NodeList';
    }

  },
  toString: {
    writable: true,
    configurable: true,

    value() {
      return '[object NodeList]';
    }

  }
});
setPrototypeOf(StaticNodeList, NodeList);
function createStaticNodeList(items) {
  const nodeList = create(StaticNodeList.prototype);
  setHiddenField$1(nodeList, Items, items);
  forEach.call(items, (item, index) => {
    defineProperty(nodeList, index, {
      value: item,
      enumerable: true,
      configurable: true
    });
  });
  return nodeList;
}

const {
  createFieldName: createFieldName$2,
  getHiddenField: getHiddenField$2,
  setHiddenField: setHiddenField$2
} = fields;
const Items$1 = createFieldName$2('items');

function isValidHTMLCollectionName(name) {
  return name !== 'length' && isNaN(name);
}

function getNodeHTMLCollectionName(node) {
  return node.getAttribute('id') || node.getAttribute('name');
}

function StaticHTMLCollection() {
  throw new TypeError('Illegal constructor');
}

StaticHTMLCollection.prototype = create(HTMLCollection.prototype, {
  constructor: {
    writable: true,
    configurable: true,
    value: StaticHTMLCollection
  },
  item: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(index) {
      return this[index];
    }

  },
  length: {
    enumerable: true,
    configurable: true,

    get() {
      return getHiddenField$2(this, Items$1).length;
    }

  },
  namedItem: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(name) {
      if (isValidHTMLCollectionName(name) && this[name]) {
        return this[name];
      }

      const items = getHiddenField$2(this, Items$1);

      for (let len = items.length - 1; len >= 0; len -= 1) {
        const item = items[len];
        const nodeName = getNodeHTMLCollectionName(item);

        if (nodeName === name) {
          return item;
        }
      }

      return null;
    }

  },
  forEach: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(cb, thisArg) {
      forEach.call(getHiddenField$2(this, Items$1), cb, thisArg);
    }

  },
  entries: {
    writable: true,
    enumerable: true,
    configurable: true,

    value() {
      return ArrayMap.call(getHiddenField$2(this, Items$1), (v, i) => [i, v]);
    }

  },
  keys: {
    writable: true,
    enumerable: true,
    configurable: true,

    value() {
      return ArrayMap.call(getHiddenField$2(this, Items$1), (v, i) => i);
    }

  },
  values: {
    writable: true,
    enumerable: true,
    configurable: true,

    value() {
      return getHiddenField$2(this, Items$1);
    }

  },
  [Symbol.iterator]: {
    writable: true,
    configurable: true,

    value() {
      let nextIndex = 0;
      return {
        next: () => {
          const items = getHiddenField$2(this, Items$1);
          return nextIndex < items.length ? {
            value: items[nextIndex++],
            done: false
          } : {
            done: true
          };
        }
      };
    }

  },
  [Symbol.toStringTag]: {
    configurable: true,

    get() {
      return 'HTMLCollection';
    }

  },
  toString: {
    writable: true,
    configurable: true,

    value() {
      return '[object HTMLCollection]';
    }

  }
});
setPrototypeOf(StaticHTMLCollection, HTMLCollection);
function createStaticHTMLCollection(items) {
  const collection = create(StaticHTMLCollection.prototype);
  setHiddenField$2(collection, Items$1, items);
  forEach.call(items, (item, index) => {
    defineProperty(collection, index, {
      value: item,
      enumerable: true,
      configurable: true
    });
  });
  return collection;
}

function getInnerHTML(node) {
  let s = '';
  const childNodes = getFilteredChildNodes(node);

  for (let i = 0, len = childNodes.length; i < len; i += 1) {
    s += getOuterHTML(childNodes[i]);
  }

  return s;
}

const escapeAttrRegExp = /[&\u00A0"]/g;
const escapeDataRegExp = /[&\u00A0<>]/g;
const {
  replace,
  toLowerCase
} = String.prototype;

function escapeReplace(c) {
  switch (c) {
    case '&':
      return '&amp;';

    case '<':
      return '&lt;';

    case '>':
      return '&gt;';

    case '"':
      return '&quot;';

    case '\u00A0':
      return '&nbsp;';

    default:
      return '';
  }
}

function escapeAttr(s) {
  return replace.call(s, escapeAttrRegExp, escapeReplace);
}

function escapeData(s) {
  return replace.call(s, escapeDataRegExp, escapeReplace);
}

const voidElements = new Set(['AREA', 'BASE', 'BR', 'COL', 'COMMAND', 'EMBED', 'HR', 'IMG', 'INPUT', 'KEYGEN', 'LINK', 'META', 'PARAM', 'SOURCE', 'TRACK', 'WBR']);
const plaintextParents = new Set(['STYLE', 'SCRIPT', 'XMP', 'IFRAME', 'NOEMBED', 'NOFRAMES', 'PLAINTEXT', 'NOSCRIPT']);
function getOuterHTML(node) {
  switch (node.nodeType) {
    case ELEMENT_NODE:
      {
        const {
          attributes: attrs
        } = node;
        const tagName = tagNameGetter.call(node);
        let s = '<' + toLowerCase.call(tagName);

        for (let i = 0, attr; attr = attrs[i]; i++) {
          s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
        }

        s += '>';

        if (voidElements.has(tagName)) {
          return s;
        }

        return s + getInnerHTML(node) + '</' + toLowerCase.call(tagName) + '>';
      }

    case TEXT_NODE:
      {
        const {
          data,
          parentNode
        } = node;

        if (parentNode instanceof Element && plaintextParents.has(tagNameGetter.call(parentNode))) {
          return data;
        }

        return escapeData(data);
      }

    case CDATA_SECTION_NODE:
      {
        return `<!CDATA[[${node.data}]]>`;
      }

    case PROCESSING_INSTRUCTION_NODE:
      {
        return `<?${node.target} ${node.data}?>`;
      }

    case COMMENT_NODE:
      {
        return `<!--${node.data}-->`;
      }

    default:
      {
        return '';
      }
  }
}

const {
  getHiddenField: getHiddenField$3,
  setHiddenField: setHiddenField$3,
  createFieldName: createFieldName$3
} = fields;
const ShadowRootResolverKey = '$shadowResolver$';
const InternalSlot = createFieldName$3('shadowRecord', 'synthetic-shadow');
const {
  createDocumentFragment
} = document;

function getInternalSlot(root) {
  const record = getHiddenField$3(root, InternalSlot);

  if (isUndefined(record)) {
    throw new TypeError();
  }

  return record;
}

const ShadowResolverPrivateKey = '$$ShadowResolverKey$$';
defineProperty(Node.prototype, ShadowRootResolverKey, {
  set(fn) {
    this[ShadowResolverPrivateKey] = fn;
    setNodeOwnerKey(this, fn.nodeKey);
  },

  get() {
    return this[ShadowResolverPrivateKey];
  },

  configurable: true,
  enumerable: true
});
function getShadowRootResolver(node) {
  return node[ShadowRootResolverKey];
}
function setShadowRootResolver(node, fn) {
  node[ShadowRootResolverKey] = fn;
}
function isDelegatingFocus(host) {
  return getInternalSlot(host).delegatesFocus;
}
function getHost(root) {
  return getInternalSlot(root).host;
}
function getShadowRoot(elm) {
  return getInternalSlot(elm).shadowRoot;
}
function isHostElement(elm) {
  return !isUndefined(getHiddenField$3(elm, InternalSlot));
}
let uid = 0;
function attachShadow(elm, options) {
  if (!isUndefined(getHiddenField$3(elm, InternalSlot))) {
    throw new Error(`Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.`);
  }

  const {
    mode,
    delegatesFocus
  } = options;
  const doc = getOwnerDocument(elm);
  const sr = createDocumentFragment.call(doc);
  const record = {
    mode,
    delegatesFocus: !!delegatesFocus,
    host: elm,
    shadowRoot: sr
  };
  setHiddenField$3(sr, InternalSlot, record);
  setHiddenField$3(elm, InternalSlot, record);

  const shadowResolver = () => sr;

  const x = shadowResolver.nodeKey = uid++;
  setNodeKey(elm, x);
  setShadowRootResolver(sr, shadowResolver);
  setPrototypeOf(sr, SyntheticShadowRoot.prototype);
  return sr;
}
const SyntheticShadowRootDescriptors = {
  constructor: {
    writable: true,
    configurable: true,
    value: SyntheticShadowRoot
  },
  toString: {
    writable: true,
    configurable: true,

    value() {
      return `[object ShadowRoot]`;
    }

  }
};
const ShadowRootDescriptors = {
  activeElement: {
    enumerable: true,
    configurable: true,

    get() {
      const host = getHost(this);
      const doc = getOwnerDocument(host);
      const activeElement = DocumentPrototypeActiveElement.call(doc);

      if (isNull(activeElement)) {
        return activeElement;
      }

      if ((compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) === 0) {
        return null;
      }

      let node = activeElement;

      while (!isNodeOwnedBy(host, node)) {
        node = parentElementGetter.call(node);
      }

      if (isSlotElement(node)) {
        return null;
      }

      return node;
    }

  },
  delegatesFocus: {
    configurable: true,

    get() {
      return getInternalSlot(this).delegatesFocus;
    }

  },
  elementFromPoint: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(left, top) {
      const host = getHost(this);
      const doc = getOwnerDocument(host);
      const element = elementFromPoint.call(doc, left, top);

      if (isNull(element)) {
        return element;
      }

      return retarget(this, pathComposer(element, true));
    }

  },
  elementsFromPoint: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(_left, _top) {
      throw new Error();
    }

  },
  getSelection: {
    writable: true,
    enumerable: true,
    configurable: true,

    value() {
      throw new Error();
    }

  },
  host: {
    enumerable: true,
    configurable: true,

    get() {
      return getHost(this);
    }

  },
  mode: {
    configurable: true,

    get() {
      return getInternalSlot(this).mode;
    }

  },
  styleSheets: {
    enumerable: true,
    configurable: true,

    get() {
      throw new Error();
    }

  }
};
const NodePatchDescriptors = {
  insertBefore: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(newChild, refChild) {
      insertBefore.call(getHost(this), newChild, refChild);
      return newChild;
    }

  },
  removeChild: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(oldChild) {
      removeChild.call(getHost(this), oldChild);
      return oldChild;
    }

  },
  appendChild: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(newChild) {
      appendChild.call(getHost(this), newChild);
      return newChild;
    }

  },
  replaceChild: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(newChild, oldChild) {
      replaceChild.call(getHost(this), newChild, oldChild);
      return oldChild;
    }

  },
  addEventListener: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(type, listener, options) {
      addShadowRootEventListener(this, type, listener, options);
    }

  },
  removeEventListener: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(type, listener, options) {
      removeShadowRootEventListener(this, type, listener, options);
    }

  },
  baseURI: {
    enumerable: true,
    configurable: true,

    get() {
      return getHost(this).baseURI;
    }

  },
  childNodes: {
    enumerable: true,
    configurable: true,

    get() {
      return createStaticNodeList(shadowRootChildNodes(this));
    }

  },
  compareDocumentPosition: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(otherNode) {
      const host = getHost(this);

      if (this === otherNode) {
        return 0;
      } else if (this.contains(otherNode)) {
        return 20;
      } else if (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) {
        return 37;
      } else {
        return 35;
      }
    }

  },
  contains: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(otherNode) {
      if (this === otherNode) {
        return true;
      }

      const host = getHost(this);
      return (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0 && isNodeOwnedBy(host, otherNode);
    }

  },
  firstChild: {
    enumerable: true,
    configurable: true,

    get() {
      const childNodes = getInternalChildNodes(this);
      return childNodes[0] || null;
    }

  },
  lastChild: {
    enumerable: true,
    configurable: true,

    get() {
      const childNodes = getInternalChildNodes(this);
      return childNodes[childNodes.length - 1] || null;
    }

  },
  hasChildNodes: {
    writable: true,
    enumerable: true,
    configurable: true,

    value() {
      const childNodes = getInternalChildNodes(this);
      return childNodes.length > 0;
    }

  },
  isConnected: {
    enumerable: true,
    configurable: true,

    get() {
      return isConnected.call(getHost(this));
    }

  },
  nextSibling: {
    enumerable: true,
    configurable: true,

    get() {
      return null;
    }

  },
  previousSibling: {
    enumerable: true,
    configurable: true,

    get() {
      return null;
    }

  },
  nodeName: {
    enumerable: true,
    configurable: true,

    get() {
      return '#document-fragment';
    }

  },
  nodeType: {
    enumerable: true,
    configurable: true,

    get() {
      return 11;
    }

  },
  nodeValue: {
    enumerable: true,
    configurable: true,

    get() {
      return null;
    }

  },
  ownerDocument: {
    enumerable: true,
    configurable: true,

    get() {
      return getHost(this).ownerDocument;
    }

  },
  parentElement: {
    enumerable: true,
    configurable: true,

    get() {
      return null;
    }

  },
  parentNode: {
    enumerable: true,
    configurable: true,

    get() {
      return null;
    }

  },
  textContent: {
    enumerable: true,
    configurable: true,

    get() {
      const childNodes = getInternalChildNodes(this);
      let textContent = '';

      for (let i = 0, len = childNodes.length; i < len; i += 1) {
        const currentNode = childNodes[i];

        if (currentNode.nodeType !== COMMENT_NODE) {
          textContent += getTextContent(currentNode);
        }
      }

      return textContent;
    },

    set(v) {
      const host = getHost(this);
      textContextSetter.call(host, v);
    }

  },
  getRootNode: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(options) {
      return !isUndefined(options) && isTrue$1(options.composed) ? getHost(this).getRootNode(options) : this;
    }

  }
};
const ElementPatchDescriptors = {
  innerHTML: {
    enumerable: true,
    configurable: true,

    get() {
      const childNodes = getInternalChildNodes(this);
      let innerHTML = '';

      for (let i = 0, len = childNodes.length; i < len; i += 1) {
        innerHTML += getOuterHTML(childNodes[i]);
      }

      return innerHTML;
    },

    set(v) {
      const host = getHost(this);
      innerHTMLSetter.call(host, v);
    }

  }
};
const ParentNodePatchDescriptors = {
  childElementCount: {
    enumerable: true,
    configurable: true,

    get() {
      return this.children.length;
    }

  },
  children: {
    enumerable: true,
    configurable: true,

    get() {
      return createStaticHTMLCollection(ArrayFilter.call(shadowRootChildNodes(this), elm => elm instanceof Element));
    }

  },
  firstElementChild: {
    enumerable: true,
    configurable: true,

    get() {
      return this.children[0] || null;
    }

  },
  lastElementChild: {
    enumerable: true,
    configurable: true,

    get() {
      const {
        children
      } = this;
      return children.item(children.length - 1) || null;
    }

  },
  querySelector: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(selectors) {
      return shadowRootQuerySelector(this, selectors);
    }

  },
  querySelectorAll: {
    writable: true,
    enumerable: true,
    configurable: true,

    value(selectors) {
      return createStaticNodeList(shadowRootQuerySelectorAll(this, selectors));
    }

  }
};
assign(SyntheticShadowRootDescriptors, NodePatchDescriptors, ParentNodePatchDescriptors, ElementPatchDescriptors, ShadowRootDescriptors);
function SyntheticShadowRoot() {
  throw new TypeError('Illegal constructor');
}
SyntheticShadowRoot.prototype = create(DocumentFragment.prototype, SyntheticShadowRootDescriptors);
function getIE11FakeShadowRootPlaceholder(host) {
  const shadowRoot = getShadowRoot(host);
  let c = shadowRoot.$$placeholder$$;

  if (!isUndefined(c)) {
    return c;
  }

  const doc = getOwnerDocument(host);
  c = shadowRoot.$$placeholder$$ = createComment.call(doc, '');
  defineProperties(c, {
    childNodes: {
      get() {
        return shadowRoot.childNodes;
      },

      enumerable: true,
      configurable: true
    },
    tagName: {
      get() {
        return `#shadow-root (${shadowRoot.mode})`;
      },

      enumerable: true,
      configurable: true
    }
  });
  return c;
}

function foldSlotElement(slot) {
  let parent = parentElementGetter.call(slot);

  while (!isNull(parent) && isSlotElement(parent)) {
    slot = parent;
    parent = parentElementGetter.call(slot);
  }

  return slot;
}

function isNodeSlotted(host, node) {
  if (process.env.NODE_ENV !== 'production') {
    assert.invariant(host instanceof HTMLElement, `isNodeSlotted() should be called with a host as the first argument instead of ${host}`);
    assert.invariant(node instanceof Node, `isNodeSlotted() should be called with a node as the second argument instead of ${node}`);
    assert.invariant(compareDocumentPosition.call(node, host) & DOCUMENT_POSITION_CONTAINS, `isNodeSlotted() should never be called with a node that is not a child node of ${host}`);
  }

  const hostKey = getNodeKey(host);
  let currentElement = node instanceof Element ? node : parentElementGetter.call(node);

  while (!isNull(currentElement) && currentElement !== host) {
    const elmOwnerKey = getNodeNearestOwnerKey(currentElement);
    const parent = parentElementGetter.call(currentElement);

    if (elmOwnerKey === hostKey) {
      return isSlotElement(currentElement);
    } else if (parent === host) {
      return false;
    } else if (!isNull(parent) && getNodeNearestOwnerKey(parent) !== elmOwnerKey) {
      if (isSlotElement(parent)) {
        currentElement = getNodeOwner(foldSlotElement(parent));

        if (!isNull(currentElement)) {
          if (currentElement === host) {
            return true;
          } else if (getNodeNearestOwnerKey(currentElement) === hostKey) {
            return true;
          }
        }
      } else {
        return false;
      }
    } else {
      currentElement = parent;
    }
  }

  return false;
}

function getNodeOwner(node) {
  if (!(node instanceof Node)) {
    return null;
  }

  const ownerKey = getNodeNearestOwnerKey(node);

  if (isUndefined(ownerKey)) {
    return null;
  }

  let nodeOwner = node;

  while (!isNull(nodeOwner) && getNodeKey(nodeOwner) !== ownerKey) {
    nodeOwner = parentNodeGetter.call(nodeOwner);
  }

  if (isNull(nodeOwner)) {
    return null;
  }

  return nodeOwner;
}
function isSlotElement(node) {
  return node instanceof HTMLSlotElement;
}
function isNodeOwnedBy(owner, node) {
  if (process.env.NODE_ENV !== 'production') {
    assert.invariant(owner instanceof HTMLElement, `isNodeOwnedBy() should be called with an element as the first argument instead of ${owner}`);
    assert.invariant(node instanceof Node, `isNodeOwnedBy() should be called with a node as the second argument instead of ${node}`);
    assert.invariant(compareDocumentPosition.call(node, owner) & DOCUMENT_POSITION_CONTAINS, `isNodeOwnedBy() should never be called with a node that is not a child node of ${owner}`);
  }

  const ownerKey = getNodeNearestOwnerKey(node);
  return isUndefined(ownerKey) || getNodeKey(owner) === ownerKey;
}
function shadowRootChildNodes(root) {
  const elm = getHost(root);
  return getAllMatches(elm, arrayFromCollection(childNodesGetter.call(elm)));
}
function getAllSlottedMatches(host, nodeList) {
  const filteredAndPatched = [];

  for (let i = 0, len = nodeList.length; i < len; i += 1) {
    const node = nodeList[i];

    if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
      ArrayPush.call(filteredAndPatched, node);
    }
  }

  return filteredAndPatched;
}
function getFirstSlottedMatch(host, nodeList) {
  for (let i = 0, len = nodeList.length; i < len; i += 1) {
    const node = nodeList[i];

    if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
      return node;
    }
  }

  return null;
}
function getAllMatches(owner, nodeList) {
  const filteredAndPatched = [];

  for (let i = 0, len = nodeList.length; i < len; i += 1) {
    const node = nodeList[i];
    const isOwned = isNodeOwnedBy(owner, node);

    if (isOwned) {
      ArrayPush.call(filteredAndPatched, node);
    }
  }

  return filteredAndPatched;
}
function getFirstMatch(owner, nodeList) {
  for (let i = 0, len = nodeList.length; i < len; i += 1) {
    if (isNodeOwnedBy(owner, nodeList[i])) {
      return nodeList[i];
    }
  }

  return null;
}
function shadowRootQuerySelector(root, selector) {
  const elm = getHost(root);
  const nodeList = arrayFromCollection(querySelectorAll.call(elm, selector));
  return getFirstMatch(elm, nodeList);
}
function shadowRootQuerySelectorAll(root, selector) {
  const elm = getHost(root);
  const nodeList = querySelectorAll.call(elm, selector);
  return getAllMatches(elm, arrayFromCollection(nodeList));
}
function getFilteredChildNodes(node) {
  let children;

  if (!isHostElement(node) && !isSlotElement(node)) {
    children = childNodesGetter.call(node);
    return arrayFromCollection(children);
  }

  if (isHostElement(node)) {
    const slots = arrayFromCollection(querySelectorAll.call(node, 'slot'));
    const resolver = getShadowRootResolver(getShadowRoot(node));
    return ArrayReduce.call(slots, (seed, slot) => {
      if (resolver === getShadowRootResolver(slot)) {
        ArrayPush.apply(seed, getFilteredSlotAssignedNodes(slot));
      }

      return seed;
    }, []);
  } else {
    children = arrayFromCollection(childNodesGetter.call(node));
    const resolver = getShadowRootResolver(node);
    return ArrayReduce.call(children, (seed, child) => {
      if (resolver === getShadowRootResolver(child)) {
        ArrayPush.call(seed, child);
      }

      return seed;
    }, []);
  }
}
function getFilteredSlotAssignedNodes(slot) {
  const owner = getNodeOwner(slot);

  if (isNull(owner)) {
    return [];
  }

  const childNodes = arrayFromCollection(childNodesGetter.call(slot));
  return ArrayReduce.call(childNodes, (seed, child) => {
    if (!isNodeOwnedBy(owner, child)) {
      ArrayPush.call(seed, child);
    }

    return seed;
  }, []);
}

const OwnerKey = '$$OwnerKey$$';
const OwnKey = '$$OwnKey$$';
const hasNativeSymbolsSupport$2 = Symbol('x').toString() === 'Symbol(x)';
function getNodeOwnerKey(node) {
  return node[OwnerKey];
}
function setNodeOwnerKey(node, value) {
  if (process.env.NODE_ENV !== 'production') {
    defineProperty(node, OwnerKey, {
      value,
      configurable: true
    });
  } else {
    node[OwnerKey] = value;
  }
}
function setNodeKey(node, value) {
  if (process.env.NODE_ENV !== 'production') {
    defineProperty(node, OwnKey, {
      value
    });
  } else {
    node[OwnKey] = value;
  }
}
function getNodeNearestOwnerKey(node) {
  let ownerNode = node;
  let ownerKey;

  while (!isNull(ownerNode)) {
    ownerKey = ownerNode[OwnerKey];

    if (!isUndefined(ownerKey)) {
      return ownerKey;
    }

    ownerNode = parentNodeGetter.call(ownerNode);
  }
}
function getNodeKey(node) {
  return node[OwnKey];
}
function isNodeShadowed(node) {
  return !isUndefined(getNodeOwnerKey(node));
}
function isNodeDeepShadowed(node) {
  return !isUndefined(getNodeNearestOwnerKey(node));
}
function hasMountedChildren(node) {
  return isSlotElement(node) || isHostElement(node);
}

function getShadowParent(node, value) {
  const owner = getNodeOwner(node);

  if (value === owner) {
    return getShadowRoot(owner);
  } else if (value instanceof Element) {
    if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {
      return value;
    } else if (!isNull(owner) && isSlotElement(value)) {
      const slotOwner = getNodeOwner(value);

      if (!isNull(slotOwner) && isNodeOwnedBy(owner, slotOwner)) {
        return slotOwner;
      }
    }
  }

  return null;
}

function hasChildNodesPatched() {
  return getInternalChildNodes(this).length > 0;
}

function firstChildGetterPatched() {
  const childNodes = getInternalChildNodes(this);
  return childNodes[0] || null;
}

function lastChildGetterPatched() {
  const childNodes = getInternalChildNodes(this);
  return childNodes[childNodes.length - 1] || null;
}

function textContentGetterPatched() {
  return getTextContent(this);
}

function textContentSetterPatched(value) {
  textContextSetter.call(this, value);
}

function parentNodeGetterPatched() {
  const value = parentNodeGetter.call(this);

  if (isNull(value)) {
    return value;
  }

  return getShadowParent(this, value);
}

function parentElementGetterPatched() {
  const value = parentNodeGetter.call(this);

  if (isNull(value)) {
    return null;
  }

  const parentNode = getShadowParent(this, value);
  return parentNode instanceof Element ? parentNode : null;
}

function compareDocumentPositionPatched(otherNode) {
  if (this.getRootNode() === otherNode) {
    return 10;
  } else if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
    return 35;
  }

  return compareDocumentPosition.call(this, otherNode);
}

function containsPatched(otherNode) {
  if (otherNode == null || getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
    return false;
  }

  return (compareDocumentPosition.call(this, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
}

function cloneNodePatched(deep) {
  const clone = cloneNode.call(this, false);

  if (!deep) {
    return clone;
  }

  const childNodes = getInternalChildNodes(this);

  for (let i = 0, len = childNodes.length; i < len; i += 1) {
    clone.appendChild(childNodes[i].cloneNode(true));
  }

  return clone;
}

function childNodesGetterPatched() {
  if (this instanceof Element && isHostElement(this)) {
    const owner = getNodeOwner(this);
    const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));

    if (process.env.NODE_ENV !== 'production' && isFalse$1(hasNativeSymbolsSupport$2) && isExternalChildNodeAccessorFlagOn()) {
      ArrayUnshift.call(childNodes, getIE11FakeShadowRootPlaceholder(this));
    }

    return createStaticNodeList(childNodes);
  }

  return childNodesGetter.call(this);
}

const nativeGetRootNode = Node.prototype.getRootNode;
const getDocumentOrRootNode = !isUndefined(nativeGetRootNode) ? nativeGetRootNode : function () {
  let node = this;
  let nodeParent;

  while (!isNull(nodeParent = parentNodeGetter.call(node))) {
    node = nodeParent;
  }

  return node;
};

function getNearestRoot(node) {
  const ownerNode = getNodeOwner(node);

  if (isNull(ownerNode)) {
    return getDocumentOrRootNode.call(node);
  }

  return getShadowRoot(ownerNode);
}

function getRootNodePatched(options) {
  const composed = isUndefined(options) ? false : !!options.composed;
  return isTrue$1(composed) ? getDocumentOrRootNode.call(this, options) : getNearestRoot(this);
}

defineProperties(Node.prototype, {
  firstChild: {
    get() {
      if (hasMountedChildren(this)) {
        return firstChildGetterPatched.call(this);
      }

      return firstChildGetter.call(this);
    },

    enumerable: true,
    configurable: true
  },
  lastChild: {
    get() {
      if (hasMountedChildren(this)) {
        return lastChildGetterPatched.call(this);
      }

      return lastChildGetter.call(this);
    },

    enumerable: true,
    configurable: true
  },
  textContent: {
    get() {
      if (!runtimeFlags.ENABLE_NODE_PATCH) {
        if (isNodeShadowed(this) || isHostElement(this)) {
          return textContentGetterPatched.call(this);
        }

        return textContentGetter.call(this);
      }

      if (isGlobalPatchingSkipped(this)) {
        return textContentGetter.call(this);
      }

      return textContentGetterPatched.call(this);
    },

    set: textContentSetterPatched,
    enumerable: true,
    configurable: true
  },
  parentNode: {
    get() {
      if (isNodeShadowed(this)) {
        return parentNodeGetterPatched.call(this);
      }

      return parentNodeGetter.call(this);
    },

    enumerable: true,
    configurable: true
  },
  parentElement: {
    get() {
      if (isNodeShadowed(this)) {
        return parentElementGetterPatched.call(this);
      }

      return parentElementGetter.call(this);
    },

    enumerable: true,
    configurable: true
  },
  childNodes: {
    get() {
      if (hasMountedChildren(this)) {
        return childNodesGetterPatched.call(this);
      }

      return childNodesGetter.call(this);
    },

    enumerable: true,
    configurable: true
  },
  hasChildNodes: {
    value() {
      if (hasMountedChildren(this)) {
        return hasChildNodesPatched.call(this);
      }

      return hasChildNodes.call(this);
    },

    enumerable: true,
    writable: true,
    configurable: true
  },
  compareDocumentPosition: {
    value(otherNode) {
      if (isGlobalPatchingSkipped(this)) {
        return compareDocumentPosition.call(this, otherNode);
      }

      return compareDocumentPositionPatched.call(this, otherNode);
    },

    enumerable: true,
    writable: true,
    configurable: true
  },
  contains: {
    value(otherNode) {
      if (!runtimeFlags.ENABLE_NODE_PATCH) {
        if (otherNode == null) {
          return false;
        }

        if (isNodeShadowed(this) || isHostElement(this)) {
          return containsPatched.call(this, otherNode);
        }

        return contains.call(this, otherNode);
      }

      if (isGlobalPatchingSkipped(this)) {
        return contains.call(this, otherNode);
      }

      return containsPatched.call(this, otherNode);
    },

    enumerable: true,
    writable: true,
    configurable: true
  },
  cloneNode: {
    value(deep) {
      if (!runtimeFlags.ENABLE_NODE_PATCH) {
        if (isNodeShadowed(this) || isHostElement(this)) {
          return cloneNodePatched.call(this, deep);
        }

        return cloneNode.call(this, deep);
      }

      if (isTrue$1(deep)) {
        if (isGlobalPatchingSkipped(this)) {
          return cloneNode.call(this, deep);
        }

        return cloneNodePatched.call(this, deep);
      }

      return cloneNode.call(this, deep);
    },

    enumerable: true,
    writable: true,
    configurable: true
  },
  getRootNode: {
    value: getRootNodePatched,
    enumerable: true,
    configurable: true,
    writable: true
  }
});
let internalChildNodeAccessorFlag = false;
function isExternalChildNodeAccessorFlagOn() {
  return !internalChildNodeAccessorFlag;
}
const getInternalChildNodes = process.env.NODE_ENV !== 'production' && isFalse$1(hasNativeSymbolsSupport$2) ? function (node) {
  internalChildNodeAccessorFlag = true;
  let childNodes;
  let error = null;

  try {
    childNodes = node.childNodes;
  } catch (e) {
    error = e;
  } finally {
    internalChildNodeAccessorFlag = false;

    if (!isNull(error)) {
      throw error;
    }
  }

  return childNodes;
} : function (node) {
  return node.childNodes;
};

if (hasOwnProperty.call(HTMLElement.prototype, 'contains')) {
  defineProperty(HTMLElement.prototype, 'contains', getOwnPropertyDescriptor(Node.prototype, 'contains'));
}

if (hasOwnProperty.call(HTMLElement.prototype, 'parentElement')) {
  defineProperty(HTMLElement.prototype, 'parentElement', getOwnPropertyDescriptor(Node.prototype, 'parentElement'));
}

function elemFromPoint(left, top) {
  const element = elementFromPoint.call(this, left, top);

  if (isNull(element)) {
    return element;
  }

  return retarget(this, pathComposer(element, true));
}

Document.prototype.elementFromPoint = elemFromPoint;
defineProperty(Document.prototype, 'activeElement', {
  get() {
    let node = DocumentPrototypeActiveElement.call(this);

    if (isNull(node)) {
      return node;
    }

    while (!isUndefined(getNodeOwnerKey(node))) {
      node = parentElementGetter.call(node);

      if (isNull(node)) {
        return null;
      }
    }

    if (node.tagName === 'HTML') {
      node = this.body;
    }

    return node;
  },

  enumerable: true,
  configurable: true
});
defineProperty(Document.prototype, 'getElementById', {
  value() {
    const elm = getElementById.apply(this, ArraySlice.call(arguments));

    if (isNull(elm)) {
      return null;
    }

    return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm) ? elm : null;
  },

  writable: true,
  enumerable: true,
  configurable: true
});
defineProperty(Document.prototype, 'querySelector', {
  value() {
    const elements = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
    const filtered = ArrayFind.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
    return !isUndefined(filtered) ? filtered : null;
  },

  writable: true,
  enumerable: true,
  configurable: true
});
defineProperty(Document.prototype, 'querySelectorAll', {
  value() {
    const elements = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
    const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
    return createStaticNodeList(filtered);
  },

  writable: true,
  enumerable: true,
  configurable: true
});
defineProperty(Document.prototype, 'getElementsByClassName', {
  value() {
    const elements = arrayFromCollection(getElementsByClassName$1.apply(this, ArraySlice.call(arguments)));
    const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
    return createStaticHTMLCollection(filtered);
  },

  writable: true,
  enumerable: true,
  configurable: true
});
defineProperty(Document.prototype, 'getElementsByTagName', {
  value() {
    const elements = arrayFromCollection(getElementsByTagName$1.apply(this, ArraySlice.call(arguments)));
    const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
    return createStaticHTMLCollection(filtered);
  },

  writable: true,
  enumerable: true,
  configurable: true
});
defineProperty(Document.prototype, 'getElementsByTagNameNS', {
  value() {
    const elements = arrayFromCollection(getElementsByTagNameNS$1.apply(this, ArraySlice.call(arguments)));
    const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
    return createStaticHTMLCollection(filtered);
  },

  writable: true,
  enumerable: true,
  configurable: true
});
defineProperty(getOwnPropertyDescriptor(HTMLDocument.prototype, 'getElementsByName') ? HTMLDocument.prototype : Document.prototype, 'getElementsByName', {
  value() {
    const elements = arrayFromCollection(getElementsByName.apply(this, ArraySlice.call(arguments)));
    const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
    return createStaticNodeList(filtered);
  },

  writable: true,
  enumerable: true,
  configurable: true
});

Object.defineProperty(window, 'ShadowRoot', {
  value: SyntheticShadowRoot,
  configurable: true,
  writable: true
});

function doesEventNeedsPatch(e) {
  const originalTarget = eventTargetGetter.call(e);
  return originalTarget instanceof Node && isNodeDeepShadowed(originalTarget);
}

function getEventListenerWrapper(fnOrObj) {
  let wrapperFn = null;

  try {
    wrapperFn = fnOrObj.$$lwcEventWrapper$$;

    if (!wrapperFn) {
      const isHandlerFunction = typeof fnOrObj === 'function';

      wrapperFn = fnOrObj.$$lwcEventWrapper$$ = function (e) {
        if (doesEventNeedsPatch(e)) {
          patchEvent(e);
        }

        return isHandlerFunction ? fnOrObj.call(this, e) : fnOrObj.handleEvent && fnOrObj.handleEvent(e);
      };
    }
  } catch (e) {}

  return wrapperFn;
}

function windowAddEventListener$1(type, fnOrObj, optionsOrCapture) {
  const handlerType = typeof fnOrObj;

  if (handlerType !== 'function' && handlerType !== 'object') {
    return;
  }

  if (handlerType === 'object' && (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {
    return;
  }

  const wrapperFn = getEventListenerWrapper(fnOrObj);
  windowAddEventListener.call(this, type, wrapperFn, optionsOrCapture);
}

function windowRemoveEventListener$1(type, fnOrObj, optionsOrCapture) {
  const wrapperFn = getEventListenerWrapper(fnOrObj);
  windowRemoveEventListener.call(this, type, wrapperFn || fnOrObj, optionsOrCapture);
}

function addEventListener$1(type, fnOrObj, optionsOrCapture) {
  const handlerType = typeof fnOrObj;

  if (handlerType !== 'function' && handlerType !== 'object') {
    return;
  }

  if (handlerType === 'object' && (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {
    return;
  }

  const wrapperFn = getEventListenerWrapper(fnOrObj);
  addEventListener.call(this, type, wrapperFn, optionsOrCapture);
}

function removeEventListener$1(type, fnOrObj, optionsOrCapture) {
  const wrapperFn = getEventListenerWrapper(fnOrObj);
  removeEventListener.call(this, type, wrapperFn || fnOrObj, optionsOrCapture);
}

window.addEventListener = windowAddEventListener$1;
window.removeEventListener = windowRemoveEventListener$1;
const protoToBePatched = typeof EventTarget !== 'undefined' ? EventTarget.prototype : Node.prototype;
defineProperties(protoToBePatched, {
  addEventListener: {
    value: addEventListener$1,
    enumerable: true,
    writable: true,
    configurable: true
  },
  removeEventListener: {
    value: removeEventListener$1,
    enumerable: true,
    writable: true,
    configurable: true
  }
});

const composedDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'composed');
function detect$1() {
  if (!composedDescriptor) {
    return false;
  }

  let clickEvent = new Event('click');
  const button = document.createElement('button');
  button.addEventListener('click', event => clickEvent = event);
  button.click();
  return !composedDescriptor.get.call(clickEvent);
}

const originalClickDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'click');

function handleClick(event) {
  Object.defineProperty(event, 'composed', {
    configurable: true,
    enumerable: true,

    get() {
      return true;
    }

  });
}

function apply$1() {
  HTMLElement.prototype.click = function () {
    addEventListener.call(this, 'click', handleClick);

    try {
      originalClickDescriptor.value.call(this);
    } finally {
      removeEventListener.call(this, 'click', handleClick);
    }
  };
}

if (detect$1()) {
  apply$1();
}

function detect$2() {
  return Object.getOwnPropertyDescriptor(Event.prototype, 'composed') === undefined;
}

function apply$2() {
  const composedEvents = assign(create(null), {
    blur: 1,
    focus: 1,
    focusin: 1,
    focusout: 1,
    click: 1,
    dblclick: 1,
    mousedown: 1,
    mouseenter: 1,
    mouseleave: 1,
    mousemove: 1,
    mouseout: 1,
    mouseover: 1,
    mouseup: 1,
    wheel: 1,
    beforeinput: 1,
    input: 1,
    keydown: 1,
    keyup: 1,
    compositionstart: 1,
    compositionupdate: 1,
    compositionend: 1,
    touchstart: 1,
    touchend: 1,
    touchmove: 1,
    touchcancel: 1,
    pointerover: 1,
    pointerenter: 1,
    pointerdown: 1,
    pointermove: 1,
    pointerup: 1,
    pointercancel: 1,
    pointerout: 1,
    pointerleave: 1,
    gotpointercapture: 1,
    lostpointercapture: 1,
    dragstart: 1,
    drag: 1,
    dragenter: 1,
    dragleave: 1,
    dragover: 1,
    drop: 1,
    dragend: 1,
    DOMActivate: 1,
    DOMFocusIn: 1,
    DOMFocusOut: 1,
    keypress: 1
  });
  Object.defineProperties(Event.prototype, {
    composed: {
      get() {
        const {
          type
        } = this;
        return composedEvents[type] === 1;
      },

      configurable: true,
      enumerable: true
    }
  });
}

if (detect$2()) {
  apply$2();
}

const OriginalCustomEvent = CustomEvent;

function PatchedCustomEvent(type, eventInitDict) {
  const event = new OriginalCustomEvent(type, eventInitDict);
  Object.defineProperties(event, {
    composed: {
      get() {
        return !!(eventInitDict && eventInitDict.composed);
      },

      configurable: true,
      enumerable: true
    }
  });
  return event;
}

PatchedCustomEvent.prototype = OriginalCustomEvent.prototype;
window.CustomEvent = PatchedCustomEvent;

const originalComposedGetter = Object.getOwnPropertyDescriptor(Event.prototype, 'composed').get;
Object.defineProperties(FocusEvent.prototype, {
  composed: {
    get() {
      const {
        isTrusted
      } = this;
      const composed = originalComposedGetter.call(this);

      if (isTrusted && composed === false) {
        return true;
      }

      return composed;
    },

    enumerable: true,
    configurable: true
  }
});

function detect$3() {
  return typeof HTMLIFrameElement !== 'undefined';
}

function apply$3() {
  const desc = getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow');
  const {
    get: originalGetter
  } = desc;

  desc.get = function () {
    const original = originalGetter.call(this);

    if (isNull(original) || isUndefined(getNodeOwnerKey(this))) {
      return original;
    }

    return wrapIframeWindow(original);
  };

  defineProperty(HTMLIFrameElement.prototype, 'contentWindow', desc);
}

function wrapIframeWindow(win) {
  return {
    addEventListener() {
      return win.addEventListener.apply(win, arguments);
    },

    blur() {
      return win.blur.apply(win, arguments);
    },

    close() {
      return win.close.apply(win, arguments);
    },

    focus() {
      return win.focus.apply(win, arguments);
    },

    postMessage() {
      return win.postMessage.apply(win, arguments);
    },

    removeEventListener() {
      return win.removeEventListener.apply(win, arguments);
    },

    get closed() {
      return win.closed;
    },

    get frames() {
      return win.frames;
    },

    get length() {
      return win.length;
    },

    get location() {
      return win.location;
    },

    set location(value) {
      win.location = value;
    },

    get opener() {
      return win.opener;
    },

    get parent() {
      return win.parent;
    },

    get self() {
      return win.self;
    },

    get top() {
      return win.top;
    },

    get window() {
      return win.window;
    }

  };
}

if (detect$3()) {
  apply$3();
}

const OriginalMutationObserver = MutationObserver;
const {
  disconnect: originalDisconnect,
  observe: originalObserve,
  takeRecords: originalTakeRecords
} = OriginalMutationObserver.prototype;
const wrapperLookupField = '$$lwcObserverCallbackWrapper$$';
const observerLookupField = '$$lwcNodeObservers$$';
const observerToNodesMap = new WeakMap();

function retargetMutationRecord(originalRecord) {
  const {
    addedNodes,
    removedNodes,
    target,
    type
  } = originalRecord;
  const retargetedRecord = create(MutationRecord.prototype);
  defineProperties(retargetedRecord, {
    addedNodes: {
      get() {
        return addedNodes;
      },

      enumerable: true,
      configurable: true
    },
    removedNodes: {
      get() {
        return removedNodes;
      },

      enumerable: true,
      configurable: true
    },
    type: {
      get() {
        return type;
      },

      enumerable: true,
      configurable: true
    },
    target: {
      get() {
        return target.shadowRoot;
      },

      enumerable: true,
      configurable: true
    }
  });
  return retargetedRecord;
}

function isQualifiedObserver(observer, target) {
  let parentNode = target;

  while (!isNull(parentNode)) {
    const parentNodeObservers = parentNode[observerLookupField];

    if (!isUndefined(parentNodeObservers) && (parentNodeObservers[0] === observer || ArrayIndexOf.call(parentNodeObservers, observer) !== -1)) {
      return true;
    }

    parentNode = parentNode.parentNode;
  }

  return false;
}

function filterMutationRecords(mutations, observer) {
  return ArrayReduce.call(mutations, (filteredSet, record) => {
    const {
      target,
      addedNodes,
      removedNodes,
      type
    } = record;

    if (type === 'childList' && !isUndefined(getNodeKey(target))) {
      if (addedNodes.length > 0) {
        const sampleNode = addedNodes[0];

        if (isQualifiedObserver(observer, sampleNode)) {
          if (target[observerLookupField] && (target[observerLookupField][0] === observer || ArrayIndexOf.call(target[observerLookupField], observer) !== -1)) {
            ArrayPush.call(filteredSet, record);
          } else {
            ArrayPush.call(filteredSet, retargetMutationRecord(record));
          }
        }
      } else {
        const shadowRoot = target.shadowRoot;
        const sampleNode = removedNodes[0];

        if (getNodeNearestOwnerKey(target) === getNodeNearestOwnerKey(sampleNode) && isQualifiedObserver(observer, target)) {
          ArrayPush.call(filteredSet, record);
        } else if (shadowRoot && shadowRoot[observerLookupField] && (shadowRoot[observerLookupField][0] === observer || ArrayIndexOf.call(shadowRoot[observerLookupField], observer) !== -1)) {
          ArrayPush.call(filteredSet, retargetMutationRecord(record));
        }
      }
    } else {
      if (isQualifiedObserver(observer, target)) {
        ArrayPush.call(filteredSet, record);
      }
    }

    return filteredSet;
  }, []);
}

function getWrappedCallback(callback) {
  let wrappedCallback = callback[wrapperLookupField];

  if (isUndefined(wrappedCallback)) {
    wrappedCallback = callback[wrapperLookupField] = (mutations, observer) => {
      const filteredRecords = filterMutationRecords(mutations, observer);

      if (filteredRecords.length === 0) {
        return;
      }

      callback.call(observer, filteredRecords, observer);
    };
  }

  return wrappedCallback;
}

function PatchedMutationObserver(callback) {
  const wrappedCallback = getWrappedCallback(callback);
  const observer = new OriginalMutationObserver(wrappedCallback);
  return observer;
}

function patchedDisconnect() {
  originalDisconnect.call(this);
  const observedNodes = observerToNodesMap.get(this);

  if (!isUndefined(observedNodes)) {
    forEach.call(observedNodes, observedNode => {
      const observers = observedNode[observerLookupField];

      if (!isUndefined(observers)) {
        const index = ArrayIndexOf.call(observers, this);

        if (index !== -1) {
          ArraySplice.call(observers, index, 1);
        }
      }
    });
    observedNodes.length = 0;
  }
}

function patchedObserve(target, options) {
  if (isUndefined(target[observerLookupField])) {
    defineProperty(target, observerLookupField, {
      value: []
    });
  }

  if (ArrayIndexOf.call(target[observerLookupField], this) === -1) {
    ArrayPush.call(target[observerLookupField], this);
  }

  if (target instanceof SyntheticShadowRoot) {
    target = target.host;
  }

  if (observerToNodesMap.has(this)) {
    const observedNodes = observerToNodesMap.get(this);

    if (ArrayIndexOf.call(observedNodes, target) === -1) {
      ArrayPush.call(observedNodes, target);
    }
  } else {
    observerToNodesMap.set(this, [target]);
  }

  return originalObserve.call(this, target, options);
}

function patchedTakeRecords() {
  return filterMutationRecords(originalTakeRecords.call(this), this);
}

PatchedMutationObserver.prototype = OriginalMutationObserver.prototype;
PatchedMutationObserver.prototype.disconnect = patchedDisconnect;
PatchedMutationObserver.prototype.observe = patchedObserve;
PatchedMutationObserver.prototype.takeRecords = patchedTakeRecords;
defineProperty(window, 'MutationObserver', {
  value: PatchedMutationObserver,
  configurable: true,
  writable: true
});

let observer;
const {
  createFieldName: createFieldName$4,
  getHiddenField: getHiddenField$4,
  setHiddenField: setHiddenField$4
} = fields;
const observerConfig = {
  childList: true
};
const SlotChangeKey = createFieldName$4('slotchange', 'synthetic-shadow');

function initSlotObserver() {
  return new MO(mutations => {
    const slots = [];
    forEach.call(mutations, mutation => {
      if (process.env.NODE_ENV !== 'production') {
        assert.invariant(mutation.type === 'childList', `Invalid mutation type: ${mutation.type}. This mutation handler for slots should only handle "childList" mutations.`);
      }

      const {
        target: slot
      } = mutation;

      if (ArrayIndexOf.call(slots, slot) === -1) {
        ArrayPush.call(slots, slot);
        dispatchEvent.call(slot, new CustomEvent('slotchange'));
      }
    });
  });
}

function getFilteredSlotFlattenNodes(slot) {
  const childNodes = arrayFromCollection(childNodesGetter.call(slot));
  return ArrayReduce.call(childNodes, (seed, child) => {
    if (child instanceof Element && isSlotElement(child)) {
      ArrayPush.apply(seed, getFilteredSlotFlattenNodes(child));
    } else {
      ArrayPush.call(seed, child);
    }

    return seed;
  }, []);
}

function assignedSlotGetterPatched() {
  const parentNode = parentNodeGetter.call(this);

  if (isNull(parentNode) || !isSlotElement(parentNode) || getNodeNearestOwnerKey(parentNode) === getNodeNearestOwnerKey(this)) {
    return null;
  }

  return parentNode;
}
defineProperties(HTMLSlotElement.prototype, {
  addEventListener: {
    value(type, listener, options) {
      HTMLElement.prototype.addEventListener.call(this, type, listener, options);

      if (type === 'slotchange' && !getHiddenField$4(this, SlotChangeKey)) {
        setHiddenField$4(this, SlotChangeKey, true);

        if (!observer) {
          observer = initSlotObserver();
        }

        MutationObserverObserve.call(observer, this, observerConfig);
      }
    },

    writable: true,
    enumerable: true,
    configurable: true
  },
  assignedElements: {
    value(options) {
      const flatten = !isUndefined(options) && isTrue$1(options.flatten);
      const nodes = flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
      return ArrayFilter.call(nodes, node => node instanceof Element);
    },

    writable: true,
    enumerable: true,
    configurable: true
  },
  assignedNodes: {
    value(options) {
      const flatten = !isUndefined(options) && isTrue$1(options.flatten);
      return flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
    },

    writable: true,
    enumerable: true,
    configurable: true
  },
  name: {
    get() {
      const name = getAttribute.call(this, 'name');
      return isNull(name) ? '' : name;
    },

    set(value) {
      setAttribute.call(this, 'name', value);
    },

    enumerable: true,
    configurable: true
  },
  childNodes: {
    get() {
      if (isNodeShadowed(this)) {
        const owner = getNodeOwner(this);
        const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
        return createStaticNodeList(childNodes);
      }

      return childNodesGetter.call(this);
    },

    enumerable: true,
    configurable: true
  }
});

defineProperties(Text.prototype, {
  assignedSlot: {
    get: assignedSlotGetterPatched,
    enumerable: true,
    configurable: true
  }
});

function getNonPatchedFilteredArrayOfNodes(context, unfilteredNodes) {
  let filtered;
  const ownerKey = getNodeOwnerKey(context);

  if (!isUndefined(ownerKey)) {
    if (isHostElement(context)) {
      const owner = getNodeOwner(context);

      if (isNull(owner)) {
        filtered = [];
      } else if (getNodeKey(context)) {
        filtered = getAllSlottedMatches(context, unfilteredNodes);
      } else {
        filtered = getAllMatches(owner, unfilteredNodes);
      }
    } else {
      filtered = ArrayFilter.call(unfilteredNodes, elm => getNodeNearestOwnerKey(elm) === ownerKey);
    }
  } else if (context instanceof HTMLBodyElement) {
    filtered = ArrayFilter.call(unfilteredNodes, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context));
  } else {
    filtered = ArraySlice.call(unfilteredNodes);
  }

  return filtered;
}

var ShadowDomSemantic;

(function (ShadowDomSemantic) {
  ShadowDomSemantic[ShadowDomSemantic["Disabled"] = 0] = "Disabled";
  ShadowDomSemantic[ShadowDomSemantic["Enabled"] = 1] = "Enabled";
})(ShadowDomSemantic || (ShadowDomSemantic = {}));

function innerHTMLGetterPatched() {
  const childNodes = getInternalChildNodes(this);
  let innerHTML = '';

  for (let i = 0, len = childNodes.length; i < len; i += 1) {
    innerHTML += getOuterHTML(childNodes[i]);
  }

  return innerHTML;
}

function outerHTMLGetterPatched() {
  return getOuterHTML(this);
}

function attachShadowPatched(options) {
  return attachShadow(this, options);
}

function shadowRootGetterPatched() {
  if (isHostElement(this)) {
    const shadow = getShadowRoot(this);

    if (shadow.mode === 'open') {
      return shadow;
    }
  }

  return null;
}

function childrenGetterPatched() {
  const owner = getNodeOwner(this);
  const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
  return createStaticHTMLCollection(ArrayFilter.call(childNodes, node => node instanceof Element));
}

function childElementCountGetterPatched() {
  return this.children.length;
}

function firstElementChildGetterPatched() {
  return this.children[0] || null;
}

function lastElementChildGetterPatched() {
  const {
    children
  } = this;
  return children.item(children.length - 1) || null;
}

defineProperties(Element.prototype, {
  innerHTML: {
    get() {
      if (!runtimeFlags.ENABLE_ELEMENT_PATCH) {
        if (isNodeShadowed(this) || isHostElement(this)) {
          return innerHTMLGetterPatched.call(this);
        }

        return innerHTMLGetter.call(this);
      }

      if (isGlobalPatchingSkipped(this)) {
        return innerHTMLGetter.call(this);
      }

      return innerHTMLGetterPatched.call(this);
    },

    set(v) {
      innerHTMLSetter.call(this, v);
    },

    enumerable: true,
    configurable: true
  },
  outerHTML: {
    get() {
      if (!runtimeFlags.ENABLE_ELEMENT_PATCH) {
        if (isNodeShadowed(this) || isHostElement(this)) {
          return outerHTMLGetterPatched.call(this);
        }

        return outerHTMLGetter.call(this);
      }

      if (isGlobalPatchingSkipped(this)) {
        return outerHTMLGetter.call(this);
      }

      return outerHTMLGetterPatched.call(this);
    },

    set(v) {
      outerHTMLSetter.call(this, v);
    },

    enumerable: true,
    configurable: true
  },
  attachShadow: {
    value: attachShadowPatched,
    enumerable: true,
    writable: true,
    configurable: true
  },
  shadowRoot: {
    get: shadowRootGetterPatched,
    enumerable: true,
    configurable: true
  },
  children: {
    get() {
      if (hasMountedChildren(this)) {
        return childrenGetterPatched.call(this);
      }

      return childrenGetter.call(this);
    },

    enumerable: true,
    configurable: true
  },
  childElementCount: {
    get() {
      if (hasMountedChildren(this)) {
        return childElementCountGetterPatched.call(this);
      }

      return childElementCountGetter.call(this);
    },

    enumerable: true,
    configurable: true
  },
  firstElementChild: {
    get() {
      if (hasMountedChildren(this)) {
        return firstElementChildGetterPatched.call(this);
      }

      return firstElementChildGetter.call(this);
    },

    enumerable: true,
    configurable: true
  },
  lastElementChild: {
    get() {
      if (hasMountedChildren(this)) {
        return lastElementChildGetterPatched.call(this);
      }

      return lastElementChildGetter.call(this);
    },

    enumerable: true,
    configurable: true
  },
  assignedSlot: {
    get: assignedSlotGetterPatched,
    enumerable: true,
    configurable: true
  }
});

if (hasOwnProperty.call(HTMLElement.prototype, 'innerHTML')) {
  defineProperty(HTMLElement.prototype, 'innerHTML', getOwnPropertyDescriptor(Element.prototype, 'innerHTML'));
}

if (hasOwnProperty.call(HTMLElement.prototype, 'outerHTML')) {
  defineProperty(HTMLElement.prototype, 'outerHTML', getOwnPropertyDescriptor(Element.prototype, 'outerHTML'));
}

if (hasOwnProperty.call(HTMLElement.prototype, 'children')) {
  defineProperty(HTMLElement.prototype, 'children', getOwnPropertyDescriptor(Element.prototype, 'children'));
}

function querySelectorPatched() {
  const nodeList = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));

  if (isHostElement(this)) {
    const owner = getNodeOwner(this);

    if (isNull(owner)) {
      return null;
    } else if (getNodeKey(this)) {
      return getFirstSlottedMatch(this, nodeList);
    } else {
      return getFirstMatch(owner, nodeList);
    }
  } else if (isNodeShadowed(this)) {
    const ownerKey = getNodeOwnerKey(this);

    if (!isUndefined(ownerKey)) {
      const elm = ArrayFind.call(nodeList, elm => getNodeNearestOwnerKey(elm) === ownerKey);
      return isUndefined(elm) ? null : elm;
    } else {
      if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
        return nodeList.length === 0 ? null : nodeList[0];
      }

      const contextNearestOwnerKey = getNodeNearestOwnerKey(this);
      const elm = ArrayFind.call(nodeList, elm => getNodeNearestOwnerKey(elm) === contextNearestOwnerKey);
      return isUndefined(elm) ? null : elm;
    }
  } else {
    if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
      if (!(this instanceof HTMLBodyElement)) {
        const elm = nodeList[0];
        return isUndefined(elm) ? null : elm;
      }
    }

    const elm = ArrayFind.call(nodeList, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(this));
    return isUndefined(elm) ? null : elm;
  }
}

function getFilteredArrayOfNodes(context, unfilteredNodes, shadowDomSemantic) {
  let filtered;

  if (isHostElement(context)) {
    const owner = getNodeOwner(context);

    if (isNull(owner)) {
      filtered = [];
    } else if (getNodeKey(context)) {
      filtered = getAllSlottedMatches(context, unfilteredNodes);
    } else {
      filtered = getAllMatches(owner, unfilteredNodes);
    }
  } else if (isNodeShadowed(context)) {
    const ownerKey = getNodeOwnerKey(context);

    if (!isUndefined(ownerKey)) {
      filtered = ArrayFilter.call(unfilteredNodes, elm => getNodeNearestOwnerKey(elm) === ownerKey);
    } else if (shadowDomSemantic === ShadowDomSemantic.Enabled) {
      const contextNearestOwnerKey = getNodeNearestOwnerKey(context);
      filtered = ArrayFilter.call(unfilteredNodes, elm => getNodeNearestOwnerKey(elm) === contextNearestOwnerKey);
    } else {
      filtered = ArraySlice.call(unfilteredNodes);
    }
  } else {
    if (context instanceof HTMLBodyElement || shadowDomSemantic === ShadowDomSemantic.Enabled) {
      filtered = ArrayFilter.call(unfilteredNodes, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context));
    } else {
      filtered = ArraySlice.call(unfilteredNodes);
    }
  }

  return filtered;
}

defineProperties(Element.prototype, {
  querySelector: {
    value: querySelectorPatched,
    writable: true,
    enumerable: true,
    configurable: true
  },
  querySelectorAll: {
    value() {
      const nodeList = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));

      if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
        const filteredResults = getFilteredArrayOfNodes(this, nodeList, ShadowDomSemantic.Disabled);
        return createStaticNodeList(filteredResults);
      }

      return createStaticNodeList(getFilteredArrayOfNodes(this, nodeList, ShadowDomSemantic.Enabled));
    },

    writable: true,
    enumerable: true,
    configurable: true
  }
});

if (process.env.NODE_ENV !== 'test') {
  defineProperties(Element.prototype, {
    getElementsByClassName: {
      value() {
        const elements = arrayFromCollection(getElementsByClassName.apply(this, ArraySlice.call(arguments)));

        if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
          return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
        }

        const filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
        return createStaticHTMLCollection(filteredResults);
      },

      writable: true,
      enumerable: true,
      configurable: true
    },
    getElementsByTagName: {
      value() {
        const elements = arrayFromCollection(getElementsByTagName.apply(this, ArraySlice.call(arguments)));

        if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
          return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
        }

        const filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
        return createStaticHTMLCollection(filteredResults);
      },

      writable: true,
      enumerable: true,
      configurable: true
    },
    getElementsByTagNameNS: {
      value() {
        const elements = arrayFromCollection(getElementsByTagNameNS.apply(this, ArraySlice.call(arguments)));

        if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
          return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
        }

        const filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
        return createStaticHTMLCollection(filteredResults);
      },

      writable: true,
      enumerable: true,
      configurable: true
    }
  });
}

if (hasOwnProperty.call(HTMLElement.prototype, 'getElementsByClassName')) {
  defineProperty(HTMLElement.prototype, 'getElementsByClassName', getOwnPropertyDescriptor(Element.prototype, 'getElementsByClassName'));
}

const {
  createFieldName: createFieldName$5,
  getHiddenField: getHiddenField$5,
  setHiddenField: setHiddenField$5
} = fields;
const TabbableElementsQuery = `
    button:not([tabindex="-1"]):not([disabled]),
    [contenteditable]:not([tabindex="-1"]),
    video[controls]:not([tabindex="-1"]),
    audio[controls]:not([tabindex="-1"]),
    [href]:not([tabindex="-1"]),
    input:not([tabindex="-1"]):not([disabled]),
    select:not([tabindex="-1"]):not([disabled]),
    textarea:not([tabindex="-1"]):not([disabled]),
    [tabindex="0"]
`;
const DidAddMouseDownListener = createFieldName$5('DidAddMouseDownListener', 'synthetic-shadow');

function isVisible(element) {
  const {
    width,
    height
  } = getBoundingClientRect.call(element);
  const noZeroSize = width > 0 || height > 0;
  return noZeroSize && getComputedStyle(element).visibility !== 'hidden';
}

function isTabbable(element) {
  return matches.call(element, TabbableElementsQuery) && isVisible(element);
}

function getTabbableSegments(host) {
  const doc = getOwnerDocument(host);
  const all = arrayFromCollection(querySelectorAll$1.call(doc, TabbableElementsQuery));
  const inner = arrayFromCollection(querySelectorAll.call(host, TabbableElementsQuery));

  if (process.env.NODE_ENV !== 'production') {
    assert.invariant(getAttribute.call(host, 'tabindex') === '-1' || isDelegatingFocus(host), `The focusin event is only relevant when the tabIndex property is -1 on the host.`);
  }

  const firstChild = inner[0];
  const lastChild = inner[inner.length - 1];
  const hostIndex = ArrayIndexOf.call(all, host);
  const firstChildIndex = hostIndex > -1 ? hostIndex : ArrayIndexOf.call(all, firstChild);
  const lastChildIndex = inner.length === 0 ? firstChildIndex + 1 : ArrayIndexOf.call(all, lastChild) + 1;
  const prev = ArraySlice.call(all, 0, firstChildIndex);
  const next = ArraySlice.call(all, lastChildIndex);
  return {
    prev,
    inner,
    next
  };
}

function getActiveElement(host) {
  const doc = getOwnerDocument(host);
  const activeElement = DocumentPrototypeActiveElement.call(doc);

  if (isNull(activeElement)) {
    return activeElement;
  }

  return (compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) !== 0 ? activeElement : null;
}

function relatedTargetPosition(host, relatedTarget) {
  const pos = compareDocumentPosition.call(host, relatedTarget);

  if (pos & DOCUMENT_POSITION_CONTAINED_BY) {
    return 0;
  } else if (pos & DOCUMENT_POSITION_PRECEDING) {
    return 1;
  } else if (pos & DOCUMENT_POSITION_FOLLOWING) {
    return 2;
  }

  return -1;
}

function muteEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}

function muteFocusEventsDuringExecution(win, func) {
  windowAddEventListener.call(win, 'focusin', muteEvent, true);
  windowAddEventListener.call(win, 'focusout', muteEvent, true);
  func();
  windowRemoveEventListener.call(win, 'focusin', muteEvent, true);
  windowRemoveEventListener.call(win, 'focusout', muteEvent, true);
}

function focusOnNextOrBlur(segment, target, relatedTarget) {
  const win = getOwnerWindow(relatedTarget);
  const next = getNextTabbable(segment, relatedTarget);

  if (isNull(next)) {
    muteFocusEventsDuringExecution(win, () => {
      target.blur();
    });
  } else {
    muteFocusEventsDuringExecution(win, () => {
      next.focus();
    });
  }
}

let letBrowserHandleFocus = false;
function disableKeyboardFocusNavigationRoutines() {
  letBrowserHandleFocus = true;
}
function enableKeyboardFocusNavigationRoutines() {
  letBrowserHandleFocus = false;
}

function skipHostHandler(event) {
  if (letBrowserHandleFocus) {
    enableKeyboardFocusNavigationRoutines();
    return;
  }

  const host = eventCurrentTargetGetter.call(event);
  const target = eventTargetGetter.call(event);

  if (host !== target) {
    return;
  }

  const relatedTarget = focusEventRelatedTargetGetter.call(event);

  if (isNull(relatedTarget)) {
    return;
  }

  const segments = getTabbableSegments(host);
  const position = relatedTargetPosition(host, relatedTarget);

  if (position === 1) {
    const findTabbableElms = isTabbableFrom.bind(null, host.getRootNode());
    const first = ArrayFind.call(segments.inner, findTabbableElms);

    if (!isUndefined(first)) {
      const win = getOwnerWindow(first);
      muteFocusEventsDuringExecution(win, () => {
        first.focus();
      });
    } else {
      focusOnNextOrBlur(segments.next, target, relatedTarget);
    }
  } else if (host === target) {
    focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
  }
}

function skipShadowHandler(event) {
  if (letBrowserHandleFocus) {
    enableKeyboardFocusNavigationRoutines();
    return;
  }

  const relatedTarget = focusEventRelatedTargetGetter.call(event);

  if (isNull(relatedTarget)) {
    return;
  }

  const host = eventCurrentTargetGetter.call(event);
  const segments = getTabbableSegments(host);

  if (ArrayIndexOf.call(segments.inner, relatedTarget) !== -1) {
    return;
  }

  const target = eventTargetGetter.call(event);
  const position = relatedTargetPosition(host, relatedTarget);

  if (position === 1) {
    focusOnNextOrBlur(segments.next, target, relatedTarget);
  }

  if (position === 2) {
    focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
  }
}

function isTabbableFrom(fromRoot, toElm) {
  if (!isTabbable(toElm)) {
    return false;
  }

  const ownerDocument = getOwnerDocument(toElm);
  let root = toElm.getRootNode();

  while (root !== ownerDocument && root !== fromRoot) {
    const sr = root;
    const host = sr.host;

    if (getAttribute.call(host, 'tabindex') === '-1') {
      return false;
    }

    root = host && host.getRootNode();
  }

  return true;
}

function getNextTabbable(tabbables, relatedTarget) {
  const len = tabbables.length;

  if (len > 0) {
    for (let i = 0; i < len; i += 1) {
      const next = tabbables[i];

      if (isTabbableFrom(relatedTarget.getRootNode(), next)) {
        return next;
      }
    }
  }

  return null;
}

function handleFocus(elm) {
  if (process.env.NODE_ENV !== 'production') {
    assert.invariant(isDelegatingFocus(elm), `Invalid attempt to handle focus event for ${toString(elm)}. ${toString(elm)} should have delegates focus true, but is not delegating focus`);
  }

  bindDocumentMousedownMouseupHandlers(elm);
  ignoreFocusIn(elm);
  addEventListener.call(elm, 'focusin', skipHostHandler, true);
}
function ignoreFocus(elm) {
  removeEventListener.call(elm, 'focusin', skipHostHandler, true);
}

function bindDocumentMousedownMouseupHandlers(elm) {
  const ownerDocument = getOwnerDocument(elm);

  if (!getHiddenField$5(ownerDocument, DidAddMouseDownListener)) {
    setHiddenField$5(ownerDocument, DidAddMouseDownListener, true);
    addEventListener.call(ownerDocument, 'mousedown', disableKeyboardFocusNavigationRoutines, true);
    addEventListener.call(ownerDocument, 'mouseup', () => {
      setTimeout(enableKeyboardFocusNavigationRoutines);
    }, true);
  }
}

function handleFocusIn(elm) {
  if (process.env.NODE_ENV !== 'production') {
    assert.invariant(tabIndexGetter.call(elm) === -1, `Invalid attempt to handle focus in  ${toString(elm)}. ${toString(elm)} should have tabIndex -1, but has tabIndex ${tabIndexGetter.call(elm)}`);
  }

  bindDocumentMousedownMouseupHandlers(elm);
  ignoreFocus(elm);
  addEventListener.call(elm, 'focusin', skipShadowHandler, true);
}
function ignoreFocusIn(elm) {
  removeEventListener.call(elm, 'focusin', skipShadowHandler, true);
}

const {
  blur,
  focus
} = HTMLElement.prototype;

function tabIndexGetterPatched() {
  if (isDelegatingFocus(this) && isFalse$1(hasAttribute.call(this, 'tabindex'))) {
    return 0;
  }

  return tabIndexGetter.call(this);
}

function tabIndexSetterPatched(value) {
  const delegatesFocus = isDelegatingFocus(this);
  const prevValue = tabIndexGetter.call(this);
  const prevHasAttr = hasAttribute.call(this, 'tabindex');
  tabIndexSetter.call(this, value);
  const currValue = tabIndexGetter.call(this);
  const currHasAttr = hasAttribute.call(this, 'tabindex');
  const didValueChange = prevValue !== currValue;

  if (prevHasAttr && (didValueChange || isFalse$1(currHasAttr))) {
    if (prevValue === -1) {
      ignoreFocusIn(this);
    }

    if (prevValue === 0 && delegatesFocus) {
      ignoreFocus(this);
    }
  }

  if (isFalse$1(currHasAttr)) {
    return;
  }

  if (prevHasAttr && currHasAttr && isFalse$1(didValueChange)) {
    return;
  }

  if (currValue === -1) {
    handleFocusIn(this);
  }

  if (currValue === 0 && delegatesFocus) {
    handleFocus(this);
  }
}

function blurPatched() {
  if (isDelegatingFocus(this)) {
    const currentActiveElement = getActiveElement(this);

    if (!isNull(currentActiveElement)) {
      currentActiveElement.blur();
      return;
    }
  }

  return blur.call(this);
}

function focusPatched() {
  disableKeyboardFocusNavigationRoutines();
  focus.call(this);
  enableKeyboardFocusNavigationRoutines();
}

defineProperties(HTMLElement.prototype, {
  tabIndex: {
    get() {
      if (isHostElement(this)) {
        return tabIndexGetterPatched.call(this);
      }

      return tabIndexGetter.call(this);
    },

    set(v) {
      if (isHostElement(this)) {
        return tabIndexSetterPatched.call(this, v);
      }

      return tabIndexSetter.call(this, v);
    },

    enumerable: true,
    configurable: true
  },
  blur: {
    value() {
      if (isHostElement(this)) {
        return blurPatched.call(this);
      }

      blur.call(this);
    },

    enumerable: true,
    writable: true,
    configurable: true
  },
  focus: {
    value() {
      focusPatched.call(this);
    },

    enumerable: true,
    writable: true,
    configurable: true
  }
});

const eventTargetGetter$1 = getOwnPropertyDescriptor(Event.prototype, 'target').get;
const eventCurrentTargetGetter$1 = getOwnPropertyDescriptor(Event.prototype, 'currentTarget').get;
const {
  dispatchEvent: dispatchEvent$1,
  addEventListener: superAddEventListener,
  removeEventListener: superRemoveEventListener
} = Node.prototype;

function addEventListenerPatched(type, listener, options) {
  if (isHostElement(this)) {
    addCustomElementEventListener(this, type, listener, options);
  } else {
    superAddEventListener.call(this, type, listener, options);
  }
}

function removeEventListenerPatched(type, listener, options) {
  if (isHostElement(this)) {
    removeCustomElementEventListener(this, type, listener, options);
  } else {
    superRemoveEventListener.call(this, type, listener, options);
  }
}

if (typeof EventTarget !== 'undefined') {
  defineProperties(EventTarget.prototype, {
    addEventListener: {
      value: addEventListenerPatched,
      enumerable: true,
      writable: true,
      configurable: true
    },
    removeEventListener: {
      value: removeEventListenerPatched,
      enumerable: true,
      writable: true,
      configurable: true
    }
  });
} else {
  defineProperties(Node.prototype, {
    addEventListener: {
      value: addEventListenerPatched,
      enumerable: true,
      writable: true,
      configurable: true
    },
    removeEventListener: {
      value: removeEventListenerPatched,
      enumerable: true,
      writable: true,
      configurable: true
    }
  });
}

const ShadowTokenPrivateKey = '$$ShadowTokenKey$$';
function getShadowToken(node) {
  return node.$shadowToken$;
}
function setShadowToken(node, shadowToken) {
  node.$shadowToken$ = shadowToken;
}
defineProperty(Element.prototype, '$shadowToken$', {
  set(shadowToken) {
    const oldShadowToken = this[ShadowTokenPrivateKey];

    if (!isUndefined(oldShadowToken) && oldShadowToken !== shadowToken) {
      removeAttribute.call(this, oldShadowToken);
    }

    if (!isUndefined(shadowToken)) {
      setAttribute.call(this, shadowToken, '');
    }

    this[ShadowTokenPrivateKey] = shadowToken;
  },

  get() {
    return this[ShadowTokenPrivateKey];
  },

  configurable: true
});

const DomManualPrivateKey = '$$DomManualKey$$';

const DocumentResolverFn = function () {};

let portalObserver;
const portalObserverConfig = {
  childList: true
};

function adoptChildNode(node, fn, shadowToken) {
  const previousNodeShadowResolver = getShadowRootResolver(node);

  if (previousNodeShadowResolver === fn) {
    return;
  }

  setShadowRootResolver(node, fn);

  if (node instanceof Element) {
    setShadowToken(node, shadowToken);

    if (isHostElement(node)) {
      return;
    }

    if (isUndefined(previousNodeShadowResolver)) {
      MutationObserverObserve.call(portalObserver, node, portalObserverConfig);
    }

    const childNodes = childNodesGetter.call(node);

    for (let i = 0, len = childNodes.length; i < len; i += 1) {
      adoptChildNode(childNodes[i], fn, shadowToken);
    }
  }
}

function initPortalObserver() {
  return new MO(mutations => {
    forEach.call(mutations, mutation => {
      const {
        target: elm,
        addedNodes,
        removedNodes
      } = mutation;
      const fn = getShadowRootResolver(elm);
      const shadowToken = getShadowToken(elm);

      for (let i = 0, len = removedNodes.length; i < len; i += 1) {
        const node = removedNodes[i];

        if (!(compareDocumentPosition.call(elm, node) & Node.DOCUMENT_POSITION_CONTAINED_BY)) {
          adoptChildNode(node, DocumentResolverFn, undefined);
        }
      }

      for (let i = 0, len = addedNodes.length; i < len; i += 1) {
        const node = addedNodes[i];

        if (compareDocumentPosition.call(elm, node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
          adoptChildNode(node, fn, shadowToken);
        }
      }
    });
  });
}

function markElementAsPortal(elm) {
  if (isUndefined(portalObserver)) {
    portalObserver = initPortalObserver();
  }

  if (isUndefined(getShadowRootResolver(elm))) {
    throw new Error(`Invalid Element`);
  }

  MutationObserverObserve.call(portalObserver, elm, portalObserverConfig);
}

defineProperty(Element.prototype, '$domManual$', {
  set(v) {
    this[DomManualPrivateKey] = v;

    if (isTrue$1(v)) {
      markElementAsPortal(this);
    }
  },

  get() {
    return this[DomManualPrivateKey];
  },

  configurable: true
});
/** version: 1.1.13-224.3 */

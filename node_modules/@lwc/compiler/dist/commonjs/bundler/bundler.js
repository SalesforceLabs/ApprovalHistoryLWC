"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const rollup_1 = require("rollup");
const errors_1 = require("@lwc/errors");
const module_resolver_1 = __importDefault(require("../rollup-plugins/module-resolver"));
const env_replacement_1 = __importDefault(require("../rollup-plugins/env-replacement"));
const transform_1 = __importDefault(require("../rollup-plugins/transform"));
const compat_1 = __importDefault(require("../rollup-plugins/compat"));
const minify_1 = __importDefault(require("../rollup-plugins/minify"));
const options_1 = require("../options");
const DEFAULT_FORMAT = 'amd';
function handleRollupWarning(diagnostics) {
    return function onwarn(warning) {
        let message;
        let origin = {};
        if (typeof warning === 'string') {
            message = warning;
        }
        else {
            message = warning.message;
            if (warning.loc) {
                const { loc, pos } = warning;
                origin = {
                    filename: loc.file,
                    location: {
                        line: loc.line,
                        column: loc.column,
                        start: pos,
                        length: 0,
                    },
                };
            }
        }
        diagnostics.push(errors_1.generateCompilerDiagnostic(errors_1.ModuleResolutionErrors.MODULE_RESOLUTION_ERROR, {
            messageArgs: [message],
            origin,
        }));
    };
}
async function bundle(options) {
    options_1.validateNormalizedCompileOptions(options);
    const { outputConfig, name, namespace } = options;
    // TODO: #1268 - remove format option once tests are converted to 'amd' format
    const format = outputConfig.format || DEFAULT_FORMAT;
    const diagnostics = [];
    const plugins = [
        module_resolver_1.default({
            options,
        }),
    ];
    // Run environment variable replacement first. This ensures that the source code is still untouched
    // at this point.
    if (Object.keys(outputConfig.env).length) {
        plugins.push(env_replacement_1.default({
            options,
        }));
    }
    plugins.push(transform_1.default({
        options,
    }));
    if (outputConfig.compat) {
        plugins.push(compat_1.default(outputConfig));
    }
    if (outputConfig.minify) {
        plugins.push(minify_1.default(outputConfig));
    }
    let code = '';
    let map = null;
    try {
        const rollupBundler = await rollup_1.rollup({
            input: name,
            plugins,
            onwarn: handleRollupWarning(diagnostics),
        });
        const { output } = await rollupBundler.generate({
            amd: { id: namespace + '/' + name },
            strict: false,
            sourcemap: outputConfig.sourcemap,
            format,
        });
        // Rollup produces multiple chunks when a module uses "import()" with a relative import
        // path. We need to ensure the compiled module only contains the main chunk.
        if (output.length > 1) {
            diagnostics.push(errors_1.generateCompilerDiagnostic(errors_1.ModuleResolutionErrors.RELATIVE_DYNAMIC_IMPORT));
        }
        const result = output[0];
        code = result.code;
        map = result.map;
    }
    catch (e) {
        // Rollup may have clobbered error.code with its own data
        if (e instanceof errors_1.CompilerError && e.pluginCode) {
            e.code = e.pluginCode;
        }
        const diagnostic = errors_1.normalizeToDiagnostic(errors_1.ModuleResolutionErrors.MODULE_RESOLUTION_ERROR, e);
        diagnostic.level = errors_1.DiagnosticLevel.Fatal;
        diagnostics.push(diagnostic);
    }
    return {
        diagnostics,
        code,
        map,
    };
}
exports.bundle = bundle;
//# sourceMappingURL=bundler.js.map
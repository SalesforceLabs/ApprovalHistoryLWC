import { ComponentConstructor } from './component';
import { VNodeData, VNodes, VCustomElement } from '../3rdparty/snabbdom/types';
import { Template } from './template';
import { ComponentDef } from './def';
import { ComponentInterface } from './component';
import { Context } from './context';
import { ReactiveObserver } from '../libs/mutation-tracker';
export interface SlotSet {
    [key: string]: VNodes;
}
export declare enum VMState {
    created = 0,
    connected = 1,
    disconnected = 2
}
export interface UninitializedVM {
    /** Component Element Back-pointer */
    readonly elm: HTMLElement;
    /** Component Definition */
    readonly def: ComponentDef;
    /** Component Context Object */
    readonly context: Context;
    /** Back-pointer to the owner VM or null for root elements */
    readonly owner: VM | null;
    /** Component Creation Index */
    idx: number;
    /** Component state, analogous to Element.isConnected */
    state: VMState;
    data: VNodeData;
    /** Shadow Children List */
    children: VNodes;
    /** Adopted Children List */
    aChildren: VNodes;
    velements: VCustomElement[];
    cmpProps: any;
    cmpSlots: SlotSet;
    cmpTrack: any;
    callHook: (cmp: ComponentInterface | undefined, fn: (...args: any[]) => any, args?: any[]) => any;
    setHook: (cmp: ComponentInterface, prop: PropertyKey, newValue: any) => void;
    getHook: (cmp: ComponentInterface, prop: PropertyKey) => any;
    isScheduled: boolean;
    isDirty: boolean;
    isRoot: boolean;
    mode: 'open' | 'closed';
    toString(): string;
    cmpTemplate?: Template;
    component?: ComponentInterface;
    cmpRoot?: ShadowRoot;
    tro?: ReactiveObserver;
    oar?: Record<PropertyKey, ReactiveObserver>;
}
export interface VM extends UninitializedVM {
    cmpTemplate: Template;
    component: ComponentInterface;
    cmpRoot: ShadowRoot;
    /** Template Reactive Observer to observe values used by the selected template */
    tro: ReactiveObserver;
    /** Reactive Observers for each of the public @api accessors */
    oar: Record<PropertyKey, ReactiveObserver>;
}
export declare function rerenderVM(vm: VM): void;
export declare function appendRootVM(vm: VM): void;
export declare function appendVM(vm: VM): void;
export declare function removeVM(vm: VM): void;
export declare function removeRootVM(vm: VM): void;
export interface CreateVMInit {
    mode: 'open' | 'closed';
    isRoot?: boolean;
    owner: VM | null;
}
export declare function createVM(elm: HTMLElement, Ctor: ComponentConstructor, options: CreateVMInit): void;
export declare function runConnectedCallback(vm: VM): void;
export declare function resetShadowRoot(vm: VM): void;
export declare function scheduleRehydration(vm: VM): void;
/**
 * Returns the component stack. Used for errors messages only.
 *
 * @param {Element} startingElement
 *
 * @return {string} The component stack for errors.
 */
export declare function getErrorComponentStack(startingElement: Element): string;
/**
 * EXPERIMENTAL: This function detects whether or not a Node is
 * controlled by a LWC template. This API is subject to
 * change or being removed.
 */
export declare function isNodeFromTemplate(node: Node): boolean;
export declare function getCustomElementVM(elm: HTMLElement): VM;
export declare function getComponentVM(component: ComponentInterface): VM;
export declare function getShadowRootVM(root: ShadowRoot): VM;
export declare function allocateInSlot(vm: VM, children: VNodes): void;
export declare function runWithBoundaryProtection(vm: VM, owner: VM | null, pre: () => void, job: () => void, post: () => void): void;

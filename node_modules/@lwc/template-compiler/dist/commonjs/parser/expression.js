"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const traverse_1 = __importDefault(require("@babel/traverse"));
const types = __importStar(require("@babel/types"));
const babylon = __importStar(require("@babel/parser"));
const esutils = __importStar(require("esutils"));
const errors_1 = require("@lwc/errors");
const ir_1 = require("../shared/ir");
exports.EXPRESSION_SYMBOL_START = '{';
exports.EXPRESSION_SYMBOL_END = '}';
const VALID_EXPRESSION_RE = /^{.+}$/;
const POTENTIAL_EXPRESSION_RE = /^.?{.+}.*$/;
const ITERATOR_NEXT_KEY = 'next';
function isExpression(source) {
    return !!source.match(VALID_EXPRESSION_RE);
}
exports.isExpression = isExpression;
function isPotentialExpression(source) {
    return !!source.match(POTENTIAL_EXPRESSION_RE);
}
exports.isPotentialExpression = isPotentialExpression;
// FIXME: Avoid throwing errors and return it properly
function parseExpression(source, element, state) {
    try {
        const parsed = babylon.parse(source);
        let expression;
        traverse_1.default(parsed, {
            enter(path) {
                const isValidNode = path.isProgram() ||
                    path.isBlockStatement() ||
                    path.isExpressionStatement() ||
                    path.isIdentifier() ||
                    path.isMemberExpression();
                errors_1.invariant(isValidNode, errors_1.ParserDiagnostics.INVALID_NODE, [path.type]);
                // Ensure expression doesn't contain multiple expressions: {foo;bar}
                const hasMultipleExpressions = path.isBlock() && path.get('body').length !== 1;
                errors_1.invariant(!hasMultipleExpressions, errors_1.ParserDiagnostics.MULTIPLE_EXPRESSIONS);
                // Retrieve the first expression and set it as return value
                if (path.isExpressionStatement() && !expression) {
                    expression = path.node.expression;
                }
            },
            MemberExpression: {
                exit(path) {
                    const shouldReportComputed = !state.config.experimentalComputedMemberExpression &&
                        path.node.computed;
                    errors_1.invariant(!shouldReportComputed, errors_1.ParserDiagnostics.COMPUTED_PROPERTY_ACCESS_NOT_ALLOWED);
                    const memberExpression = path.node;
                    const propertyIdentifier = memberExpression.property;
                    const objectIdentifier = memberExpression.object;
                    errors_1.invariant(!ir_1.isBoundToIterator(objectIdentifier, element) ||
                        propertyIdentifier.name !== ITERATOR_NEXT_KEY, errors_1.ParserDiagnostics.MODIFYING_ITERATORS_NOT_ALLOWED);
                },
            },
        });
        return expression;
    }
    catch (err) {
        err.message = `Invalid expression ${source} - ${err.message}`;
        throw err;
    }
}
exports.parseExpression = parseExpression;
function parseIdentifier(source) {
    if (esutils.keyword.isIdentifierES6(source)) {
        return types.identifier(source);
    }
    else {
        throw errors_1.generateCompilerError(errors_1.ParserDiagnostics.INVALID_IDENTIFIER, {
            messageArgs: [source],
        });
    }
}
exports.parseIdentifier = parseIdentifier;
// Returns the immediate iterator parent if it exists.
// Traverses up until it finds an element with forOf, or
// a non-template element without a forOf.
function getForOfParent(element) {
    const parent = element.parent;
    if (!parent) {
        return null;
    }
    if (parent.forOf) {
        return parent;
    }
    else if (parent.tag.toLowerCase() === 'template') {
        return getForOfParent(parent);
    }
    return null;
}
exports.getForOfParent = getForOfParent;
function getForEachParent(element) {
    if (element.forEach) {
        return element;
    }
    const parent = element.parent;
    if (parent && parent.tag.toLowerCase() === 'template') {
        return getForEachParent(parent);
    }
    return null;
}
exports.getForEachParent = getForEachParent;
function isIteratorElement(element) {
    return !!(getForOfParent(element) || getForEachParent(element));
}
exports.isIteratorElement = isIteratorElement;
//# sourceMappingURL=expression.js.map
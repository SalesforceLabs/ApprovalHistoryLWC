"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const camelcase_1 = __importDefault(require("camelcase"));
const errors_1 = require("@lwc/errors");
const expression_1 = require("./expression");
const constants_1 = require("./constants");
const ir_1 = require("../shared/ir");
function isQuotedAttribute(rawAttribute) {
    const [, value] = rawAttribute.split('=');
    return value && value.startsWith('"') && value.endsWith('"');
}
function isEscapedAttribute(rawAttribute) {
    const [, value] = rawAttribute.split('=');
    return !value || !(value.includes('{') && value.includes('}'));
}
const booleanAttributes = new Set([
    'autofocus',
    'autoplay',
    'capture',
    'checked',
    'disabled',
    'formnovalidate',
    'hidden',
    'loop',
    'multiple',
    'muted',
    'novalidate',
    'open',
    'readonly',
    'required',
    'reversed',
    'selected',
]);
function isIdReferencingAttribute(attrName) {
    return constants_1.ID_REFERENCING_ATTRIBUTES_SET.has(attrName);
}
exports.isIdReferencingAttribute = isIdReferencingAttribute;
// Whitelists http://www.w3.org/1999/xhtml namespace idref elements for which we
// allow id references.
function isAllowedFragOnlyUrlsXHTML(tagName, attrName, namespaceURI) {
    const whitelistedTags = [constants_1.HTML_TAG.A, constants_1.HTML_TAG.AREA];
    return (attrName === constants_1.ATTR_NAME.HREF &&
        whitelistedTags.includes(tagName) &&
        namespaceURI === constants_1.HTML_NAMESPACE_URI);
}
exports.isAllowedFragOnlyUrlsXHTML = isAllowedFragOnlyUrlsXHTML;
// Identifies `href/xlink:href` attributes on `use` elements in the
// http://www.w3.org/2000/svg namespace
function isSvgUseHref(tagName, attrName, namespaceURI) {
    return (
    // xlink:href is a deprecated attribute included for backwards compatibility
    [constants_1.ATTR_NAME.HREF, constants_1.ATTR_NAME.XLINK_HREF].includes(attrName) &&
        tagName === constants_1.HTML_TAG.USE &&
        namespaceURI === constants_1.SVG_NAMESPACE_URI);
}
exports.isSvgUseHref = isSvgUseHref;
function isFragmentOnlyUrl(url) {
    return /^#/.test(url);
}
exports.isFragmentOnlyUrl = isFragmentOnlyUrl;
function normalizeAttributeValue(attr, raw, tag) {
    const { name, value } = attr;
    if (booleanAttributes.has(name)) {
        if (value === 'true') {
            throw errors_1.generateCompilerError(errors_1.ParserDiagnostics.BOOLEAN_ATTRIBUTE_TRUE, {
                messageArgs: [tag, name, value],
            });
        }
        else if (value === 'false') {
            throw errors_1.generateCompilerError(errors_1.ParserDiagnostics.BOOLEAN_ATTRIBUTE_FALSE, {
                messageArgs: [tag, name, value],
            });
        }
    }
    const isQuoted = isQuotedAttribute(raw);
    const isEscaped = isEscapedAttribute(raw);
    if (!isEscaped && expression_1.isExpression(value)) {
        if (isQuoted) {
            // <input value="{myValue}" />
            // -> ambiguity if the attribute value is a template identifier or a string literal.
            const unquoted = raw.replace(/"/g, '');
            const escaped = raw.replace('"{', '"\\{');
            throw errors_1.generateCompilerError(errors_1.ParserDiagnostics.AMBIGUOUS_ATTRIBUTE_VALUE, {
                messageArgs: [raw, unquoted, escaped],
            });
        }
        // <input value={myValue} />
        // -> Valid identifier.
        return { value, escapedExpression: false };
    }
    else if (!isEscaped && expression_1.isPotentialExpression(value)) {
        const isExpressionEscaped = value.startsWith(`\\${expression_1.EXPRESSION_SYMBOL_START}`);
        const isExpressionNextToSelfClosing = value.startsWith(expression_1.EXPRESSION_SYMBOL_START) &&
            value.endsWith(`${expression_1.EXPRESSION_SYMBOL_END}/`) &&
            !isQuoted;
        if (isExpressionNextToSelfClosing) {
            // <input value={myValue}/>
            // -> By design the html parser consider the / as the last character of the attribute value.
            //    Make sure to remove strip the trailing / for self closing elements.
            return { value: value.slice(0, -1), escapedExpression: false };
        }
        else if (isExpressionEscaped) {
            // <input value="\{myValue}"/>
            // -> Valid escaped string literal
            return { value: value.slice(1), escapedExpression: true };
        }
        let escaped = raw.replace(/="?/, '="\\');
        escaped += escaped.endsWith('"') ? '' : '"';
        // Throw if the attribute value looks like an expression, but it can't be resolved by the compiler.
        throw errors_1.generateCompilerError(errors_1.ParserDiagnostics.AMBIGUOUS_ATTRIBUTE_VALUE_STRING, {
            messageArgs: [raw, escaped],
        });
    }
    // <input value="myValue"/>
    // -> Valid string literal.
    return { value, escapedExpression: false };
}
exports.normalizeAttributeValue = normalizeAttributeValue;
function attributeName(attr) {
    const { prefix, name } = attr;
    return prefix ? `${prefix}:${name}` : name;
}
exports.attributeName = attributeName;
function getAttribute(el, pattern) {
    return el.attrsList.find(attr => typeof pattern === 'string'
        ? attributeName(attr) === pattern
        : !!attributeName(attr).match(pattern));
}
exports.getAttribute = getAttribute;
function removeAttribute(el, pattern) {
    el.attrsList = el.attrsList.filter(attr => typeof pattern === 'string'
        ? attributeName(attr) !== pattern
        : !attributeName(attr).match(pattern));
}
exports.removeAttribute = removeAttribute;
function isAriaAttribute(attrName) {
    return attrName === 'role' || constants_1.ARIA_RE.test(attrName);
}
function isProhibitedIsAttribute(attrName) {
    return attrName === 'is';
}
exports.isProhibitedIsAttribute = isProhibitedIsAttribute;
function isTabIndexAttribute(attrName) {
    return attrName === 'tabindex';
}
exports.isTabIndexAttribute = isTabIndexAttribute;
function isValidTabIndexAttributeValue(value) {
    // object means it is a Node representing the expression
    return value === '0' || value === '-1';
}
exports.isValidTabIndexAttributeValue = isValidTabIndexAttributeValue;
function isAriaOrDataOrFmkAttribute(attrName) {
    return isAriaAttribute(attrName) || isFmkAttribute(attrName) || isDataAttribute(attrName);
}
exports.isAriaOrDataOrFmkAttribute = isAriaOrDataOrFmkAttribute;
function isDataAttribute(attrName) {
    return !!attrName.match(constants_1.DATA_RE);
}
function isFmkAttribute(attrName) {
    return attrName === 'key' || attrName === 'slot';
}
function isCustomElementAttribute(attrName) {
    return attrName === 'key' || attrName === 'slot' || !!attrName.match(constants_1.DATA_RE);
}
function isInputStateAttribute(element, attrName) {
    return element.tag === 'input' && (attrName === 'value' || attrName === 'checked');
}
function isAttribute(element, attrName) {
    const isCustom = ir_1.isCustomElement(element);
    if (isCustom) {
        return isCustomElementAttribute(attrName);
    }
    if (booleanAttributes.has(attrName)) {
        return false;
    }
    // Handle global attrs (common to all tags) and special attribute (role, aria, key, is, data-).
    if (constants_1.GLOBAL_ATTRIBUTE_SET.has(attrName) || isAriaOrDataOrFmkAttribute(attrName)) {
        return true;
    }
    // Handle input tag value="" and checked attributes that are only used for state initialization.
    // Because .setAttribute() won't update the value, those attributes should be considered as props.
    if (isInputStateAttribute(element, attrName)) {
        return false;
    }
    // Handle general case where only standard element have attribute value.
    return !ir_1.isCustomElement(element);
}
exports.isAttribute = isAttribute;
function isValidHTMLAttribute(tagName, attrName) {
    if (constants_1.GLOBAL_ATTRIBUTE_SET.has(attrName) ||
        isAriaOrDataOrFmkAttribute(attrName) ||
        constants_1.SVG_TAG_WHITELIST.has(tagName) ||
        constants_1.DASHED_TAGNAME_ELEMENT_SET.has(tagName) ||
        isTemplateDirective(attrName) ||
        !constants_1.KNOWN_HTML_ELEMENTS.has(tagName)) {
        return true;
    }
    const validElements = constants_1.HTML_ATTRIBUTES_REVERSE_LOOKUP[attrName];
    return !!validElements && (!validElements.length || validElements.includes(tagName));
}
exports.isValidHTMLAttribute = isValidHTMLAttribute;
function isTemplateDirective(attrName) {
    return constants_1.TEMPLATE_DIRECTIVES.some((directive) => {
        return directive.test(attrName);
    });
}
function shouldCamelCaseAttribute(element, attrName) {
    const { tag } = element;
    const isDataAttributeOrFmk = isDataAttribute(attrName) || isFmkAttribute(attrName);
    const isSvgTag = constants_1.SVG_TAG_WHITELIST.has(tag);
    return !isSvgTag && !isDataAttributeOrFmk;
}
function attributeToPropertyName(element, attrName) {
    let propName = attrName;
    if (shouldCamelCaseAttribute(element, attrName)) {
        const attrToSplit = constants_1.ATTRS_PROPS_TRANFORMS[propName] || propName;
        propName = attrToSplit
            .split('_')
            .map(camelcase_1.default)
            .join('_');
    }
    return propName;
}
exports.attributeToPropertyName = attributeToPropertyName;
//# sourceMappingURL=attribute.js.map
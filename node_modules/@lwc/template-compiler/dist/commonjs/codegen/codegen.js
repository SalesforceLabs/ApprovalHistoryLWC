"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const babylon = __importStar(require("@babel/parser"));
const t = __importStar(require("@babel/types"));
const esutils = __importStar(require("esutils"));
const camelcase_1 = __importDefault(require("camelcase"));
const util_1 = require("util");
const RENDER_APIS = {
    iterator: { name: 'i', alias: 'api_iterator' },
    flatten: { name: 'f', alias: 'api_flatten' },
    element: { name: 'h', alias: 'api_element' },
    slot: { name: 's', alias: 'api_slot' },
    customElement: { name: 'c', alias: 'api_custom_element' },
    dynamicCtor: { name: 'dc', alias: 'api_dynamic_component' },
    bind: { name: 'b', alias: 'api_bind' },
    functionBind: { name: 'fb', alias: 'function_bind' },
    locatorListenerBind: { name: 'll', alias: 'locator_listener' },
    text: { name: 't', alias: 'api_text' },
    dynamic: { name: 'd', alias: 'api_dynamic' },
    key: { name: 'k', alias: 'api_key' },
    tabindex: { name: 'ti', alias: 'api_tab_index' },
    scopedId: { name: 'gid', alias: 'api_scoped_id' },
    scopedFragId: { name: 'fid', alias: 'api_scoped_frag_id' },
};
class CodeGen {
    constructor() {
        this.currentId = 0;
        this.currentKey = 0;
        this.usedApis = {};
        this.usedSlots = {};
        this.memorizedIds = [];
        this.inlineStyleImports = [];
        this.inlineStyleBody = [];
    }
    generateKey() {
        return this.currentKey++;
    }
    genInlineStyles(src) {
        if (src) {
            // We get back a AST module which may have three pieces:
            // 1) import statements
            // 2) the inline function
            // 3) default export
            // We need to separate the imports and change the default export for a correct inlining
            const importDeclarations = [];
            const styleBody = [];
            // Parse the generated module code and return it's body.
            const parsed = babylon.parse(src, { sourceType: 'module' });
            const inlineStylesAst = parsed.program.body;
            inlineStylesAst.forEach(node => {
                if (t.isImportDeclaration(node)) {
                    importDeclarations.push(node);
                }
                else if (t.isExportDefaultDeclaration(node)) {
                    const stylesheetDeclaration = t.variableDeclaration('const', [
                        t.variableDeclarator(t.identifier('stylesheets'), node.declaration),
                    ]);
                    styleBody.push(stylesheetDeclaration);
                }
                else {
                    styleBody.push(node);
                }
            });
            this.inlineStyleImports = importDeclarations;
            this.inlineStyleBody = styleBody;
        }
    }
    genElement(tagName, data, children) {
        return this._renderApiCall(RENDER_APIS.element, [t.stringLiteral(tagName), data, children]);
    }
    genCustomElement(tagName, componentClass, data, children) {
        return this._renderApiCall(RENDER_APIS.customElement, [
            t.stringLiteral(tagName),
            componentClass,
            data,
            children,
        ]);
    }
    genDynamicElement(tagName, ctor, data, children) {
        return this._renderApiCall(RENDER_APIS.dynamicCtor, [
            t.stringLiteral(tagName),
            ctor,
            data,
            children,
        ]);
    }
    genText(value) {
        if (typeof value === 'string') {
            return this._renderApiCall(RENDER_APIS.text, [t.stringLiteral(value)]);
        }
        else {
            return this._renderApiCall(RENDER_APIS.dynamic, [value]);
        }
    }
    genIterator(iterable, callback) {
        return this._renderApiCall(RENDER_APIS.iterator, [iterable, callback]);
    }
    genBind(handler) {
        return this._renderApiCall(RENDER_APIS.bind, [handler]);
    }
    genFunctionBind(fn) {
        return this._renderApiCall(RENDER_APIS.functionBind, [fn]);
    }
    genLocatorBind(handler, locatorId, locatorProvider) {
        const argsList = [handler, t.stringLiteral(locatorId)];
        if (!util_1.isUndefined(locatorProvider)) {
            argsList.push(locatorProvider);
        }
        return this._renderApiCall(RENDER_APIS.locatorListenerBind, argsList);
    }
    genFlatten(children) {
        return this._renderApiCall(RENDER_APIS.flatten, children);
    }
    genKey(compilerKey, value) {
        return this._renderApiCall(RENDER_APIS.key, [compilerKey, value]);
    }
    genScopedId(id) {
        if (typeof id === 'string') {
            return this._renderApiCall(RENDER_APIS.scopedId, [t.stringLiteral(id)]);
        }
        return this._renderApiCall(RENDER_APIS.scopedId, [id]);
    }
    genScopedFragId(id) {
        if (typeof id === 'string') {
            return this._renderApiCall(RENDER_APIS.scopedFragId, [t.stringLiteral(id)]);
        }
        return this._renderApiCall(RENDER_APIS.scopedFragId, [id]);
    }
    getSlot(slotName, data, children) {
        return this._renderApiCall(RENDER_APIS.slot, [
            t.stringLiteral(slotName),
            data,
            children,
            t.identifier('$slotset'),
        ]);
    }
    genTabIndex(children) {
        return this._renderApiCall(RENDER_APIS.tabindex, children);
    }
    getMemorizationId() {
        const id = this._genUniqueIdentifier('_m');
        this.memorizedIds.push(id);
        return id;
    }
    _genUniqueIdentifier(name) {
        const id = this.currentId++;
        const prefix = this._toValidIdentifier(name);
        return t.identifier(prefix + id);
    }
    _toValidIdentifier(name) {
        return esutils.keyword.isIdentifierES6(name) ? name : camelcase_1.default(name);
    }
    _renderApiCall(primitive, params) {
        const { name, alias } = primitive;
        let identifier = this.usedApis[name];
        if (!identifier) {
            identifier = this.usedApis[name] = t.identifier(alias);
        }
        return t.callExpression(identifier, params);
    }
}
exports.default = CodeGen;
//# sourceMappingURL=codegen.js.map
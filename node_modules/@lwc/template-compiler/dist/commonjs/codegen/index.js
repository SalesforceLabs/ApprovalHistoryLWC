"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const generator_1 = __importDefault(require("@babel/generator"));
const t = __importStar(require("@babel/types"));
const template_1 = __importDefault(require("@babel/template"));
const constants_1 = require("../shared/constants");
const scope_1 = require("../shared/scope");
const ir_1 = require("../shared/ir");
const types_1 = require("../shared/types");
const stack_1 = __importDefault(require("../shared/stack"));
const helpers_1 = require("./helpers");
const codegen_1 = __importDefault(require("./codegen"));
const module_1 = require("./formatters/module");
const function_1 = require("./formatters/function");
const attribute_1 = require("../parser/attribute");
const errors_1 = require("@lwc/errors");
const TEMPLATE_FUNCTION = template_1.default(`function ${constants_1.TEMPLATE_FUNCTION_NAME}(
        ${constants_1.TEMPLATE_PARAMS.API},
        ${constants_1.TEMPLATE_PARAMS.INSTANCE},
        ${constants_1.TEMPLATE_PARAMS.SLOT_SET},
        ${constants_1.TEMPLATE_PARAMS.CONTEXT}
    ) {
        APIS;
        SLOTS;
        CONTEXT;
        return STATEMENT;
    }`, { sourceType: 'module' });
const BLACKLIST_LWC_DIRECTIVES = new Set(['dynamic']);
function generateContext(element, data, codeGen) {
    const { lwc, locator } = element;
    const contextExpressions = [];
    // LWC
    if (lwc) {
        const lwcObject = Object.keys(lwc)
            .filter(key => !BLACKLIST_LWC_DIRECTIVES.has(key))
            .map(key => {
            return t.objectProperty(t.identifier(key), t.stringLiteral(lwc[key]));
        });
        const lwcObj = t.objectProperty(t.identifier('lwc'), t.objectExpression(lwcObject));
        contextExpressions.push(lwcObj);
    }
    // Locators
    if (locator) {
        const locatorObject = [];
        const locatorId = t.objectProperty(t.identifier('id'), t.stringLiteral(locator.id));
        locatorObject.push(locatorId);
        if (locator.context) {
            let locatorContextFunction = scope_1.bindExpression(locator.context, element).expression;
            locatorContextFunction = codeGen.genFunctionBind(locatorContextFunction);
            locatorContextFunction = helpers_1.memorizeHandler(codeGen, element, locator.context, locatorContextFunction);
            locatorObject.push(t.objectProperty(t.identifier('context'), locatorContextFunction));
        }
        const contextObj = t.objectProperty(t.identifier('locator'), t.objectExpression(locatorObject));
        contextExpressions.push(contextObj);
    }
    data.push(t.objectProperty(t.identifier('context'), t.objectExpression(contextExpressions)));
}
function initialPassToCheckForIds(root) {
    let templateContainsId = false;
    ir_1.traverse(root, {
        element: {
            exit(element) {
                const { attrs, props } = element;
                if (attrs && attrs.id) {
                    templateContainsId = true;
                }
                if (props && props.id) {
                    templateContainsId = true;
                }
            },
        },
    });
    return templateContainsId;
}
function transform(root, codeGen) {
    const stack = new stack_1.default();
    stack.push(t.arrayExpression([]));
    // Initial scan to detect any id attributes in order to avoid manging href
    // values in this case. This is only temporary:
    // https://github.com/salesforce/lwc/issues/1150
    const templateContainsId = initialPassToCheckForIds(root);
    ir_1.traverse(root, {
        text: {
            exit(textNode) {
                let { value } = textNode;
                if (typeof value !== 'string') {
                    value = scope_1.bindExpression(value, textNode).expression;
                }
                stack.peek().elements.push(codeGen.genText(value));
            },
        },
        element: {
            enter() {
                // Create a new frame when visiting a child
                stack.push(t.arrayExpression([]));
            },
            exit(element) {
                if (helpers_1.isStyleSheet(element)) {
                    codeGen.genInlineStyles(element.inlineStyles);
                    return;
                }
                let children = stack.pop();
                // Apply children flattening
                if (helpers_1.shouldFlatten(element) && t.isArrayExpression(children)) {
                    children =
                        element.children.length === 1 && !helpers_1.containsDynamicChildren(element) // if it contains only one dynamic we need to flatten anyway
                            ? children.elements[0]
                            : codeGen.genFlatten([children]);
                }
                // Applied the transformation to itself
                helpers_1.isTemplate(element)
                    ? transformTemplate(element, children)
                    : transformElement(element, children, templateContainsId);
            },
        },
    });
    /** Transforms IRElement to Javascript AST node and add it at the to of the stack  */
    function transformElement(element, children, templateContainsId) {
        const databag = elementDataBag(element, templateContainsId);
        let babelElement;
        // Check wether it has the special directive lwc:dynamic
        // TODO: We should inline a isDynamicElement, but ts doesn't like it
        if (element.lwc && element.lwc.dynamic) {
            const { expression } = scope_1.bindExpression(element.lwc.dynamic, element);
            babelElement = codeGen.genDynamicElement(element.tag, expression, databag, children);
        }
        else if (ir_1.isCustomElement(element)) {
            // Make sure to register the component
            const componentClassName = element.component;
            babelElement = codeGen.genCustomElement(element.tag, helpers_1.identifierFromComponentName(componentClassName), databag, children);
        }
        else if (helpers_1.isSlot(element)) {
            const defaultSlot = children;
            babelElement = codeGen.getSlot(element.slotName, databag, defaultSlot);
        }
        else {
            babelElement = codeGen.genElement(element.tag, databag, children);
        }
        babelElement = applyInlineIf(element, babelElement);
        babelElement = applyInlineFor(element, babelElement);
        stack.peek().elements.push(babelElement);
    }
    /** Transform template IRElement and add it at the top of the stack */
    function transformTemplate(element, children) {
        let expression = applyTemplateIf(element, children);
        if (element.forEach) {
            expression = applyTemplateFor(element, expression);
            stack.peek().elements.push(expression);
        }
        else if (element.forOf) {
            expression = applyTemplateForOf(element, expression);
            stack.peek().elements.push(expression);
        }
        else if (t.isArrayExpression(expression) && element.if) {
            // Inject inlined if elements directly
            return stack.peek().elements.push(...expression.elements);
        }
        else {
            stack.peek().elements.push(expression);
        }
    }
    function applyInlineIf(element, babelNode, testExpression, falseValue = t.nullLiteral()) {
        if (!element.if) {
            return babelNode;
        }
        if (!testExpression) {
            testExpression = scope_1.bindExpression(element.if, element).expression;
        }
        let leftExpression;
        const modifier = element.ifModifier;
        if (modifier === 'true') {
            leftExpression = testExpression;
        }
        else if (modifier === 'false') {
            leftExpression = t.unaryExpression('!', testExpression);
        }
        else if (modifier === 'strict-true') {
            leftExpression = t.binaryExpression('===', testExpression, t.booleanLiteral(true));
        }
        else {
            throw errors_1.generateCompilerError(errors_1.TemplateErrors.UNKNOWN_IF_MODIFIER, {
                messageArgs: [modifier],
            });
        }
        return t.conditionalExpression(leftExpression, babelNode, falseValue);
    }
    function applyInlineFor(element, babelNode) {
        if (!element.forEach) {
            return babelNode;
        }
        const { expression, item, index } = element.forEach;
        const params = [item];
        if (index) {
            params.push(index);
        }
        const { expression: iterable } = scope_1.bindExpression(expression, element);
        const iterationFunction = t.functionExpression(undefined, params, t.blockStatement([t.returnStatement(babelNode)]));
        return codeGen.genIterator(iterable, iterationFunction);
    }
    function applyInlineForOf(element, babelNode) {
        if (!element.forOf) {
            return babelNode;
        }
        const { expression, iterator } = element.forOf;
        const { name: iteratorName } = iterator;
        const argNames = {
            value: t.identifier(`${iteratorName}Value`),
            index: t.identifier(`${iteratorName}Index`),
            first: t.identifier(`${iteratorName}First`),
            last: t.identifier(`${iteratorName}Last`),
        };
        const functionParams = Object.keys(argNames).map(key => argNames[key]);
        const iterationFunction = t.functionExpression(undefined, functionParams, t.blockStatement([t.returnStatement(babelNode)]));
        const { expression: iterable } = scope_1.bindExpression(expression, element);
        const { expression: mappedIterationFunction } = scope_1.rewriteIteratorToArguments(iterationFunction, iterator, argNames);
        return codeGen.genIterator(iterable, mappedIterationFunction);
    }
    function applyTemplateForOf(element, fragmentNodes) {
        let expression = fragmentNodes;
        if (t.isArrayExpression(expression) && expression.elements.length === 1) {
            expression = expression.elements[0];
        }
        return applyInlineForOf(element, expression);
    }
    function applyTemplateFor(element, fragmentNodes) {
        let expression = fragmentNodes;
        if (t.isArrayExpression(expression) && expression.elements.length === 1) {
            expression = expression.elements[0];
        }
        return applyInlineFor(element, expression);
    }
    function applyTemplateIf(element, fragmentNodes) {
        if (!element.if) {
            return fragmentNodes;
        }
        if (t.isArrayExpression(fragmentNodes)) {
            // Bind the expression once for all the template children
            const { expression: testExpression } = scope_1.bindExpression(element.if, element);
            return t.arrayExpression(fragmentNodes.elements.map((child) => applyInlineIf(element, child, testExpression)));
        }
        else {
            // If the template has a single children, make sure the ternary expression returns an array
            return applyInlineIf(element, fragmentNodes, undefined, t.arrayExpression([]));
        }
    }
    function generateScopedIdFunctionForIdRefAttr(idRef) {
        const expressions = idRef
            .split(/\s+/) // handle space-delimited idrefs (e.g., aria-labelledby="foo bar")
            .map(codeGen.genScopedId.bind(codeGen));
        // Embed call expressions into a template literal:
        // [api_scoped_id()] => `${api_scoped_id()}`
        // [api_scoped_id(), api_scoped_id()] => `${api_scoped_id()} ${api_scoped_id()}`
        const spacesBetweenIdRefs = ' '.repeat(expressions.length - 1).split('');
        const quasis = ['', ...spacesBetweenIdRefs, ''].map(str => t.templateElement({ raw: str }));
        return t.templateLiteral(quasis, expressions);
    }
    function computeAttrValue(attr, element, templateContainsId) {
        const { namespaceURI, tagName } = element.__original;
        switch (attr.type) {
            case types_1.IRAttributeType.Expression: {
                const { expression } = scope_1.bindExpression(attr.value, element);
                if (attr.name === 'tabindex') {
                    return codeGen.genTabIndex([expression]);
                }
                if (attr.name === 'id' || attribute_1.isIdReferencingAttribute(attr.name)) {
                    return codeGen.genScopedId(expression);
                }
                if (templateContainsId &&
                    attribute_1.isAllowedFragOnlyUrlsXHTML(tagName, attr.name, namespaceURI)) {
                    return codeGen.genScopedFragId(expression);
                }
                if (attribute_1.isSvgUseHref(tagName, attr.name, namespaceURI)) {
                    return t.callExpression(t.identifier('sanitizeAttribute'), [
                        t.stringLiteral(tagName),
                        t.stringLiteral(namespaceURI),
                        t.stringLiteral(attr.name),
                        codeGen.genScopedFragId(expression),
                    ]);
                }
                return expression;
            }
            case types_1.IRAttributeType.String: {
                if (attr.name === 'id') {
                    return codeGen.genScopedId(attr.value);
                }
                if (attribute_1.isIdReferencingAttribute(attr.name)) {
                    return generateScopedIdFunctionForIdRefAttr(attr.value);
                }
                if (templateContainsId &&
                    attribute_1.isAllowedFragOnlyUrlsXHTML(tagName, attr.name, namespaceURI) &&
                    attribute_1.isFragmentOnlyUrl(attr.value)) {
                    return codeGen.genScopedFragId(attr.value);
                }
                if (attribute_1.isSvgUseHref(tagName, attr.name, namespaceURI)) {
                    return t.callExpression(t.identifier('sanitizeAttribute'), [
                        t.stringLiteral(tagName),
                        t.stringLiteral(namespaceURI),
                        t.stringLiteral(attr.name),
                        attribute_1.isFragmentOnlyUrl(attr.value)
                            ? codeGen.genScopedFragId(attr.value)
                            : t.stringLiteral(attr.value),
                    ]);
                }
                return t.stringLiteral(attr.value);
            }
            case types_1.IRAttributeType.Boolean:
                return t.booleanLiteral(attr.value);
        }
    }
    function elementDataBag(element, templateContainsId) {
        const data = [];
        const { classMap, className, style, styleMap, attrs, props, on, forKey, locator, lwc, } = element;
        // Class attibute defined via string
        if (className) {
            const { expression: classExpression } = scope_1.bindExpression(className, element);
            data.push(t.objectProperty(t.identifier('className'), classExpression));
        }
        // Class attribute defined via object
        if (classMap) {
            const classMapObj = helpers_1.objectToAST(classMap, () => t.booleanLiteral(true));
            data.push(t.objectProperty(t.identifier('classMap'), classMapObj));
        }
        // Style attribute defined via object
        if (styleMap) {
            const styleObj = helpers_1.objectToAST(styleMap, key => typeof styleMap[key] === 'number'
                ? t.numericLiteral(styleMap[key])
                : t.stringLiteral(styleMap[key]));
            data.push(t.objectProperty(t.identifier('styleMap'), styleObj));
        }
        // Style attribute defined via string
        if (style) {
            const { expression: styleExpression } = scope_1.bindExpression(style, element);
            data.push(t.objectProperty(t.identifier('style'), styleExpression));
        }
        // Attributes
        if (attrs) {
            const attrsObj = helpers_1.objectToAST(attrs, key => {
                return computeAttrValue(attrs[key], element, templateContainsId);
            });
            data.push(t.objectProperty(t.identifier('attrs'), attrsObj));
        }
        // Properties
        if (props) {
            const propsObj = helpers_1.objectToAST(props, key => {
                return computeAttrValue(props[key], element, templateContainsId);
            });
            data.push(t.objectProperty(t.identifier('props'), propsObj));
        }
        if (lwc || locator) {
            generateContext(element, data, codeGen);
        }
        // Key property on VNode
        if (forKey) {
            // If element has user-supplied `key` or is in iterator, call `api.k`
            const { expression: forKeyExpression } = scope_1.bindExpression(forKey, element);
            const generatedKey = codeGen.genKey(t.numericLiteral(codeGen.generateKey()), forKeyExpression);
            data.push(t.objectProperty(t.identifier('key'), generatedKey));
        }
        else {
            // If stand alone element with no user-defined key
            // member expression id
            data.push(t.objectProperty(t.identifier('key'), t.numericLiteral(codeGen.generateKey())));
        }
        // Event handler
        if (on) {
            const onObj = helpers_1.objectToAST(on, key => {
                const { expression: componentHandler } = scope_1.bindExpression(on[key], element);
                let handler;
                if (locator !== undefined && key === 'click') {
                    let locatorContext;
                    if (locator.context) {
                        locatorContext = scope_1.bindExpression(locator.context, element).expression;
                        locatorContext = codeGen.genFunctionBind(locatorContext);
                    }
                    handler = codeGen.genLocatorBind(componentHandler, locator.id, locatorContext);
                }
                else {
                    handler = codeGen.genBind(componentHandler);
                }
                handler = helpers_1.memorizeHandler(codeGen, element, componentHandler, handler);
                return handler;
            });
            data.push(t.objectProperty(t.identifier('on'), onObj));
        }
        return t.objectExpression(data);
    }
    return stack.peek().elements[0];
}
function generateTemplateFunction(templateRoot, state) {
    const codeGen = new codegen_1.default();
    const statement = transform(templateRoot, codeGen);
    // Copy AST generated styles to the state
    state.inlineStyle.body = codeGen.inlineStyleBody;
    state.inlineStyle.imports = codeGen.inlineStyleImports;
    const apis = helpers_1.destructuringAssignmentFromObject(t.identifier(constants_1.TEMPLATE_PARAMS.API), Object.keys(codeGen.usedApis).map(name => t.objectProperty(t.identifier(name), codeGen.usedApis[name], false, true)));
    let slots = null;
    if (Object.keys(codeGen.usedSlots).length) {
        slots = helpers_1.destructuringAssignmentFromObject(t.identifier(constants_1.TEMPLATE_PARAMS.SLOT_SET), Object.keys(codeGen.usedSlots).map(name => t.objectProperty(t.stringLiteral(name), codeGen.usedSlots[name], false, true)));
    }
    let context = null;
    if (codeGen.memorizedIds.length) {
        context = helpers_1.destructuringAssignmentFromObject(t.identifier(constants_1.TEMPLATE_PARAMS.CONTEXT), codeGen.memorizedIds.map(id => t.objectProperty(id, id, false, true)));
    }
    return TEMPLATE_FUNCTION({
        APIS: apis,
        SLOTS: slots,
        CONTEXT: context,
        STATEMENT: statement,
    });
}
function format({ config }) {
    switch (config.format) {
        case 'function':
            return function_1.format;
        default:
            return module_1.format;
    }
}
function default_1(templateRoot, state) {
    const templateFunction = generateTemplateFunction(templateRoot, state);
    const formatter = format(state);
    const program = formatter(templateFunction, state);
    const { code } = generator_1.default(program);
    return {
        ast: program,
        code,
    };
}
exports.default = default_1;
//# sourceMappingURL=index.js.map
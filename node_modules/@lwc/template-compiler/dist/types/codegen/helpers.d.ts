import * as t from '@babel/types';
import State from '../state';
import { IRElement } from '../shared/types';
import { kebabcaseToCamelcase } from '../shared/naming';
import CodeGen from './codegen';
export declare function identifierFromComponentName(name: string): t.Identifier;
export { kebabcaseToCamelcase };
export declare function getMemberExpressionRoot(expression: t.MemberExpression): t.Identifier;
export declare function objectToAST(obj: object, valueMapper: (key: string) => t.Expression): t.ObjectExpression;
/** Returns true if the passed element is a template element */
export declare function isTemplate(element: IRElement): boolean;
export declare function isStyleSheet(element: IRElement): boolean;
/** Returns true if the passed element is a slot element */
export declare function isSlot(element: IRElement): boolean;
export declare function containsDynamicChildren(element: IRElement): boolean;
export declare function isDynamic(element: IRElement): boolean;
/**
 * Returns true if the passed element should be flattened
 * TODO: #1303 - Move this logic into the optimizing compiler. This kind of
 *       optimization should be done before the actual code generation.
 */
export declare function shouldFlatten(element: IRElement): boolean;
export declare function destructuringAssignmentFromObject(target: t.Identifier | t.MemberExpression, keys: t.ObjectProperty[], type?: string): t.VariableDeclaration;
export declare function memorizeHandler(codeGen: CodeGen, element: any, componentHandler: t.Expression, handler: t.Expression): t.Expression;
export declare function generateTemplateMetadata(state: State): t.Statement[];

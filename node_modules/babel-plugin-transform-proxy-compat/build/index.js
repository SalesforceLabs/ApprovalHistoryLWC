"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var intrinsics_1 = __importDefault(require("./visitors/intrinsics"));
var PROXY_COMPAT_MODULE_NAME = 'proxy-compat';
var PROXY_SYMBOL = '_ES5ProxyType';
var OBJECT_OPERATIONS = {
    SET_KEY: 'setKey',
    SET_KEY_POSTFIX_INCREMENT: 'setKeyPostfixIncrement',
    SET_KEY_POSTFIX_DECREMENT: 'setKeyPostfixDecrement',
    CALL_KEY: 'callKey',
    ITERABLE_KEY: 'iterableKey',
    IN_KEY: 'inKey',
    DELETE_KEY: 'deleteKey',
    INSTANCEOF_KEY: 'instanceOfKey',
};
var MICS_OPERATIONS = {
    // concat is a special operation since we have to handle cases where:
    //   - the target array is a proxy
    //   - one of the argument is a proxy
    CONCAT: 'concat',
    HAS_OWN_PROPERTY: 'hasOwnProperty',
};
var ARRAY_PROTOTYPE_COMPAT_OPERATIONS = new Set(['splice', 'pop', 'push', 'shift', 'unshift', 'concat']);
var PRAGMA_DISABLE = 'proxy-compat-disable';
var NO_TRANSFORM = Symbol('no-transform');
// List here: https://tc39.github.io/ecma262/#sec-well-known-intrinsic-objects
var INTRINSICS = [
    'Array',
    'Boolean',
    'Date',
    'Function',
    'JSON',
    'Map',
    'Math',
    'Number',
    'Object',
    'Promise',
    'Proxy',
    'RegExp',
    'Set',
    'String',
    'Symbol',
    'WeakMap',
    'WeakSet',
    'arguments',
];
var compatPlugin = function (_a) {
    var t = _a.types;
    function convertProperty(property, isComputed) {
        if (isComputed === void 0) { isComputed = false; }
        return t.isIdentifier(property) && !isComputed ? t.stringLiteral(property.name) : property;
    }
    /**
     * Retrieve the identifier for a proxy-compat API.
     */
    function resolveCompatProxyImport(memberName, keysSeen) {
        // Create a local identifier and register it
        if (!keysSeen[memberName]) {
            keysSeen[memberName] = t.identifier("__" + memberName);
        }
        return keysSeen[memberName];
    }
    function noTransform(node) {
        node[NO_TRANSFORM] = true;
        return node;
    }
    /**
     * Returns a list of properties of accessed node for a member expression.
     */
    function getMemberExpressionPropertyList(node) {
        var object = node.object, property = node.property, computed = node.computed;
        // Stop the descent when reaching a node with a NO_TRANSFORM flag
        if (node[NO_TRANSFORM]) {
            return [
                {
                    node: node,
                    computed: false,
                },
            ];
        }
        // Get the left-hand side property list recursively
        var objectPath = t.isMemberExpression(object)
            ? getMemberExpressionPropertyList(object)
            : [{ node: object, computed: false }];
        // Append the current node property access to the left-hand side property list
        return objectPath.concat([
            {
                node: property,
                computed: computed,
            },
        ]);
    }
    /**
     * Returns true if the passed node is a complex node, and should be linearized into it's own expression in the
     * expression sequence.
     */
    function shouldBeLinearized(node) {
        return (!t.isIdentifier(node) &&
            !t.isLiteral(node) &&
            !t.isThisExpression(node));
    }
    var objectTransformVisitor = {
        /**
         * Transforms:
         *      a.b     => a.__isProxy ? a.get('b') : a.b;
         *      a.b.c   => (_b = a.__isProxy ? a.get('b') : a.b, _c = _b.__isProxy ? _b.get('c') : _b.c);
         *
         * The member expression visitor transforms into an inline version of the CompatProxy.getKey. This optimization
         * avoid computed expression lookup, for all the property access on non-proxy object. IE11 is 10x slower when
         * accessing computed properties compared to identifier lookups:
         * https://github.com/salesforce/es5-proxy-compat/issues/99
         *
         * This formation is done in 2 steps:
         *      - on enter: linearization of the member expression in a sequence expression
         *      - on exit: transformation of each expression in the sequence expression into a ternary operator
         */
        MemberExpression: {
            enter: function (path) {
                var node = path.node, scope = path.scope;
                if (node[NO_TRANSFORM]) {
                    return;
                }
                var memberExpressionItems = getMemberExpressionPropertyList(node);
                // If the member expression lookup is simplistic (eg: foo.bar) the linearization can be avoided.
                if (memberExpressionItems.length === 2 && (memberExpressionItems[0].node[NO_TRANSFORM] ||
                    !shouldBeLinearized(memberExpressionItems[0].node)) &&
                    (memberExpressionItems[1].node[NO_TRANSFORM] ||
                        !shouldBeLinearized(memberExpressionItems[1].node))) {
                    return;
                }
                var root = memberExpressionItems[0], rest = memberExpressionItems.slice(1);
                // We now need to convert the member expression chain to a list of expression to a sequence of
                // expressions:
                //      a.b.c;       => (_1 = a.b, _2 = _1.c);
                //      a[0].c;      => (_1 = a[0], _2 = _1.c);
                //      a[b.c].d;    => (_1 = b.c, _2 = a[_1], _3 = _2.c);
                var sequence = [];
                // The object identifier keeps tracks of the last referenced identifier. It get initialized to the first
                // identifier in the member expression and keep getting updated as we loop over the different items of
                // the list.
                var object = root.node;
                // In order to decrease the amount of generated code, if the object on the member expression is
                // computed and if it's not a literal nor an identifier we apply the same technique by dereferencing
                // it.
                //      a().b.c;    =>  (_1 = a(), _2 = _1.b, _3 = _2.c);
                if (shouldBeLinearized(object)) {
                    var objectReference = scope.generateUidIdentifierBasedOnNode(object);
                    scope.push({ id: objectReference });
                    sequence.push(t.assignmentExpression('=', objectReference, object));
                    // The original node can be replaced now by the newly created reference
                    object = objectReference;
                }
                for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {
                    var memberExpressionItem = rest_1[_i];
                    var computed = memberExpressionItem.computed, property = memberExpressionItem.node;
                    var propertyReference = property;
                    // The same way deference the root if it's not a literal or an identifier, we also do the same for
                    // the computed properties of the member expression
                    if (computed && shouldBeLinearized(property)) {
                        propertyReference = scope.generateUidIdentifierBasedOnNode(property);
                        scope.push({ id: propertyReference });
                        sequence.push(t.assignmentExpression('=', propertyReference, property));
                    }
                    var reference = scope.generateUidIdentifierBasedOnNode(property);
                    scope.push({ id: reference });
                    sequence.push(t.assignmentExpression('=', reference, t.memberExpression(object, propertyReference, computed)));
                    // The identifier now become the new object to lookup the next property on.
                    object = reference;
                }
                path.replaceWith(t.sequenceExpression(sequence));
            },
            exit: function (path) {
                var node = path.node;
                if (node[NO_TRANSFORM]) {
                    return;
                }
                var object = node.object, property = node.property, computed = node.computed;
                // The member expression access can be transformed into ternary operator:
                //      a.b;     =>  a.__isProxy ? a.get('b') : a.b;
                //
                // We need to make all the members expression here with the NO_TRANSFORM symbol, since we know that
                // those member expression are not written by the user nor generated by another plugin.
                var isProxyLookup = noTransform(t.memberExpression(object, t.identifier(PROXY_SYMBOL)));
                var proxyGet = noTransform(t.memberExpression(object, t.identifier('get')));
                var proxyBranch = noTransform(t.callExpression(proxyGet, [
                    convertProperty(property, computed),
                ]));
                var nonProxyBranch = noTransform(t.memberExpression(object, property, computed));
                path.replaceWith(t.conditionalExpression(isProxyLookup, proxyBranch, nonProxyBranch));
            },
        },
        /**
         * Transforms:
         *      obj.f = 1;   =>   setKey(obj, "f", 1);
         */
        AssignmentExpression: function (path) {
            var _a = path.node, left = _a.left, right = _a.right, operator = _a.operator;
            var assignment;
            var args;
            // Skip assignments such as var a = 1;
            if (!t.isMemberExpression(left)) {
                return;
            }
            args = [left.object, convertProperty(left.property, left.computed), right];
            if (operator !== '=') {
                args[2] = t.binaryExpression(operator.slice(0, -1), left, right);
            }
            var id = resolveCompatProxyImport(OBJECT_OPERATIONS.SET_KEY, this.keysSeen);
            assignment = t.callExpression(id, args);
            if (assignment) {
                path.replaceWith(assignment);
            }
        },
        /**
         * Transforms:
         *     [].pop();                    =>   callKey0([], 'pop');
         *     console.log('foo');          =>   callKey1(console, 'log', 'foo');
         *     console.log('foo', 'bar');   =>   callKey2(console, 'log', 'foo', 'bar');
         *
         *     [].concat([])                =>   concat([], []);
         *     {}.hasOwnProperty('foo')     =>   hasOwnProperty({}, 'foo');
         */
        CallExpression: function (path) {
            var _a = path.node, callee = _a.callee, args = _a.arguments;
            if (t.isMemberExpression(callee) && !callee[NO_TRANSFORM]) {
                var replacement = void 0;
                var property = callee.property, object = callee.object, computed = callee.computed;
                var normalizedPropertyName = convertProperty(property, computed);
                if (t.isStringLiteral(normalizedPropertyName, { value: 'concat' })) {
                    var id = resolveCompatProxyImport(MICS_OPERATIONS.CONCAT, this.keysSeen);
                    replacement = t.callExpression(id, [object].concat(args));
                }
                else if (t.isStringLiteral(normalizedPropertyName, { value: 'hasOwnProperty' })) {
                    var id = resolveCompatProxyImport(MICS_OPERATIONS.HAS_OWN_PROPERTY, this.keysSeen);
                    replacement = t.callExpression(id, [object].concat(args));
                }
                else {
                    var operator = OBJECT_OPERATIONS.CALL_KEY + (args.length > 4 ? '' : args.length);
                    var id = resolveCompatProxyImport(operator, this.keysSeen);
                    replacement = t.callExpression(id, [object, normalizedPropertyName].concat(args));
                }
                path.replaceWith(replacement);
            }
        },
        /**
         * Transforms:
         *      delete obj.f;   =>   deleteKey(obj, 'f')
         */
        UnaryExpression: function (path) {
            var _a = path.node, operator = _a.operator, argument = _a.argument;
            if (operator === 'delete' && t.isMemberExpression(argument)) {
                var args = [argument.object, convertProperty(argument.property, argument.computed)];
                var id = resolveCompatProxyImport(OBJECT_OPERATIONS.DELETE_KEY, this.keysSeen);
                var deletion = t.callExpression(id, args);
                path.replaceWith(deletion);
            }
        },
        /**
         * Transforms:
         *      ++obj.e;   =>    _setKey(obj, "f", _getKey(obj, "f") + 1);
         *      obj.e++;   =>    __setKeyPostfixIncrement(obj, "e");
         */
        UpdateExpression: function (path) {
            var _a = path.node, operator = _a.operator, argument = _a.argument, prefix = _a.prefix;
            // Do nothing for: i++
            if (!t.isMemberExpression(argument)) {
                return;
            }
            var id;
            var args;
            if (prefix) {
                var updatedValue = t.binaryExpression(operator === '++' ? '+' : '-', argument, t.numericLiteral(1));
                id = resolveCompatProxyImport(OBJECT_OPERATIONS.SET_KEY, this.keysSeen);
                args = [argument.object, convertProperty(argument.property, argument.computed), updatedValue];
            }
            else {
                var proxyMethodName = operator === '++'
                    ? OBJECT_OPERATIONS.SET_KEY_POSTFIX_INCREMENT
                    : OBJECT_OPERATIONS.SET_KEY_POSTFIX_DECREMENT;
                id = resolveCompatProxyImport(proxyMethodName, this.keysSeen);
                args = [argument.object, convertProperty(argument.property, argument.computed)];
            }
            var unary = t.callExpression(id, args);
            path.replaceWith(unary);
        },
        /**
         * Transforms:
         *      for (let k in obj) {}   =>   for (let k in _iterableKey(obj)) {}
         */
        ForInStatement: function (path) {
            var node = path.node;
            var id = resolveCompatProxyImport(OBJECT_OPERATIONS.ITERABLE_KEY, this.keysSeen);
            var wrappedIterator = t.callExpression(id, [node.right]);
            node.right = wrappedIterator;
        },
        /**
         * Transforms:
         *      if ("x" in obj) {}   =>   if (_inKey(obj, "x")) {}
         */
        BinaryExpression: function (path) {
            var _a = path.node, operator = _a.operator, left = _a.left, right = _a.right;
            if (operator === 'instanceof') {
                var id = resolveCompatProxyImport(OBJECT_OPERATIONS.INSTANCEOF_KEY, this.keysSeen);
                var wrappedInOperator = t.callExpression(id, [left, right]);
                path.replaceWith(wrappedInOperator);
            }
            else if (operator === 'in') {
                var id = resolveCompatProxyImport(OBJECT_OPERATIONS.IN_KEY, this.keysSeen);
                var wrappedInOperator = t.callExpression(id, [right, left]);
                path.replaceWith(wrappedInOperator);
            }
        },
    };
    var markerTransformVisitor = {
        Identifier: function (path) {
            var name = path.node.name, scope = path.scope;
            if (INTRINSICS.includes(name) && scope.hasGlobal(name) && !scope.hasOwnBinding(name)) {
                noTransform(path.node);
            }
        },
        MemberExpression: {
            exit: function (path) {
                var propertyName = path.get('property').node.name;
                if ((path.get('object').isIdentifier() && path.node.object[NO_TRANSFORM]) ||
                    (propertyName &&
                        ARRAY_PROTOTYPE_COMPAT_OPERATIONS.has(propertyName) &&
                        !MICS_OPERATIONS.hasOwnProperty(propertyName.toUpperCase()))) {
                    noTransform(path.node);
                }
            },
        },
    };
    return {
        pre: function () {
            // Set to false if the file should not get the proxy compat transform
            this.applyProxyCompatTransform = true;
            // Object to record used proxy compat APIs
            this.keysSeen = Object.create(null);
        },
        visitor: {
            Program: {
                /**
                 * Look for pragma to decide if the compat transform needs to be applied.
                 * Because other transforms can change the order of the statement
                 * at the top of the file (adding extra imports), the transform look for the
                 * presence of the pragma not only at the top of the file but also in it's body.
                 */
                enter: function (path) {
                    for (var _i = 0, _a = path.node.body; _i < _a.length; _i++) {
                        var child = _a[_i];
                        // Get all the comments for program children
                        var _b = child.leadingComments, leadingComments = _b === void 0 ? [] : _b, _c = child.trailingComments, trailingComments = _c === void 0 ? [] : _c;
                        var comments = leadingComments.concat(trailingComments);
                        for (var _d = 0, comments_1 = comments; _d < comments_1.length; _d++) {
                            var comment = comments_1[_d];
                            if (comment.type === 'CommentBlock' && comment.value.trim() === PRAGMA_DISABLE) {
                                this.applyProxyCompatTransform = false;
                            }
                        }
                    }
                },
                /**
                 * Apply the compat transform on exit in order to ensure
                 * all other transformations has been applied before.
                 */
                exit: function (path, state) {
                    var _this = this;
                    // Early exit if the file should not get transformed
                    if (!this.applyProxyCompatTransform) {
                        return;
                    }
                    // It's required to do the AST traversal in 2 times.
                    // The Array transformations before the Object transformations in
                    // order to ensure the transformations are applied in the right order.
                    path.traverse(intrinsics_1.default, state);
                    path.traverse(markerTransformVisitor, state);
                    path.traverse(objectTransformVisitor, state);
                    var statements = [];
                    // Generate individual import statements for each API, eg:
                    //   import __getKey from 'proxy-compat/getKey';
                    var imports = Object.keys(this.keysSeen).map(function (apiName) {
                        return t.importDeclaration([t.importDefaultSpecifier(_this.keysSeen[apiName])], t.stringLiteral(PROXY_COMPAT_MODULE_NAME + "/" + apiName));
                    });
                    statements.push.apply(statements, imports);
                    // We need to make sure babel doesn't visit the newly created variable declaration.
                    // Otherwise it will apply the proxy transform to the member expression to retrieve the proxy APIs.
                    path.stop();
                    // Finally add to the top of the file the API declarations
                    path.unshiftContainer('body', statements);
                },
            },
        },
    };
};
exports.default = compatPlugin;
//# sourceMappingURL=module.js.map